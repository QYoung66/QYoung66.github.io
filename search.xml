<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>File类</title>
    <url>/p/11300.html</url>
    <content><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><ul>
<li>java.io.File类：<strong>文件和文件目录路径</strong>（文件夹）的抽象表示形式，与平台无关；</li>
<li>File能新建、删除、重命名文件和目录，但是File不能访问文件内容本身。如果要访问文件内容本身，则需要使用输入/输出流；</li>
<li>要在Java程序中表示一个真实存在的文件或目录，那么必须有一个File对象，但是Java程序中的一个File对象，可能没有一个真实存在的文件或目录；</li>
<li>File对象可以作为参数传递给流的构造器。</li>
</ul>
<a id="more"></a> 

<h1 id="File类的使用：常用构造器"><a href="#File类的使用：常用构造器" class="headerlink" title="File类的使用：常用构造器"></a>File类的使用：常用构造器</h1><ul>
<li><strong>File(String pathname)：</strong>通过将给定的路径名字符串转换为抽象路径名来创建新的 File实例<ul>
<li>相对路径：相对于当前Module（F:\IdeaProjects\javacourse）</li>
<li>绝对路径：包含盘符在内的文件或文件目录的路径</li>
</ul>
</li>
<li>**File(String parent, String child)**：从父路径名字符串和子路径名字符串创建新的 File实例</li>
<li>**File(File parent, String child)**：从父抽象路径名和子路径名字符串创建新的 File实例</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//File(String pathname)</span></span><br><span class="line">File file1 = <span class="keyword">new</span> File(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">File file2 = <span class="keyword">new</span> File(<span class="string">&quot;F:\\IdeaProjects\\javacourse\\hell.txt&quot;</span>);</span><br><span class="line">File file3 = <span class="keyword">new</span> File(<span class="string">&quot;F:&quot;</span> + File.separator + <span class="string">&quot;IdeaProjects&quot;</span> + File.separator + <span class="string">&quot;javacourse&quot;</span> + File.separator + <span class="string">&quot;hel.txt&quot;</span>);</span><br><span class="line">System.out.println(file1);<span class="comment">//hello.txt</span></span><br><span class="line">System.out.println(file2);<span class="comment">//F:\IdeaProjects\javacourse\hell.txt</span></span><br><span class="line">System.out.println(file3);<span class="comment">//F:\IdeaProjects\javacourse\hel.txt</span></span><br><span class="line"><span class="comment">//File(String parent, String child)</span></span><br><span class="line">File javacourse = <span class="keyword">new</span> File(<span class="string">&quot;F:\\IdeaProjects&quot;</span>, <span class="string">&quot;javacourse&quot;</span>);</span><br><span class="line">System.out.println(javacourse);<span class="comment">//F:\IdeaProjects\javacourse</span></span><br><span class="line"><span class="comment">//File(File parent, String child)</span></span><br><span class="line">File file4 = <span class="keyword">new</span> File(javacourse, <span class="string">&quot;he.txt&quot;</span>);</span><br><span class="line">System.out.println(file4);<span class="comment">//F:\IdeaProjects\javacourse\he.txt</span></span><br></pre></td></tr></table></figure>
<h1 id="File类的使用：File类的常用方法"><a href="#File类的使用：File类的常用方法" class="headerlink" title="File类的使用：File类的常用方法"></a>File类的使用：File类的常用方法</h1><h2 id="获取功能"><a href="#获取功能" class="headerlink" title="获取功能"></a>获取功能</h2><ol>
<li><strong>getAbsoluteFile()：</strong>返回此抽象路径名的绝对形式；</li>
<li><strong>getPath()：</strong>获取路径；</li>
<li><strong>getName()：</strong>获取名称；</li>
<li><strong>getParent()：</strong>获取上层文件目录路径，若无，返回null；</li>
<li><strong>length()：</strong>获取文件长度（即字节数）。不能获取目录的长度；</li>
<li><strong>lastModified()：</strong>获取最后一次的修改时间，毫秒值；</li>
<li><strong>list()：</strong>获取指定目录下的所有文件或者文件目录的名称数组；（适用于文件目录）</li>
<li><strong>listFiles()：</strong>获取指定目录下的所有文件或者文件目录的File数组。（适用于文件目录）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File file1 = <span class="keyword">new</span> File(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">File file2 = <span class="keyword">new</span> File(<span class="string">&quot;F:\\IdeaProjects\\javacourse\\io\\hi.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;########file1########&quot;</span>);</span><br><span class="line">System.out.println(file1.getAbsoluteFile());<span class="comment">//F:\IdeaProjects\javacourse\day0110\hello.txt</span></span><br><span class="line">System.out.println(file1.getName());<span class="comment">//hello.txt</span></span><br><span class="line">System.out.println(file1.getPath());<span class="comment">//hello.txt</span></span><br><span class="line">System.out.println(file1.getParent());<span class="comment">//null</span></span><br><span class="line">System.out.println(file1.length());<span class="comment">//11</span></span><br><span class="line">System.out.println(<span class="keyword">new</span> Date(file1.lastModified()));<span class="comment">//2021-01-10</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;########file2########&quot;</span>);</span><br><span class="line">System.out.println(file2.getAbsoluteFile());<span class="comment">//F:\IdeaProjects\javacourse\io\hi.txt</span></span><br><span class="line">System.out.println(file2.getName());<span class="comment">//hi.txt</span></span><br><span class="line">System.out.println(file2.getPath());<span class="comment">//F:\IdeaProjects\javacourse\io\hi.txt</span></span><br><span class="line">System.out.println(file2.getParent());<span class="comment">//F:\IdeaProjects\javacourse\io</span></span><br><span class="line">System.out.println(file2.length());<span class="comment">//0</span></span><br><span class="line">System.out.println(<span class="keyword">new</span> Date(file2.lastModified()));<span class="comment">//默认1970-01-01</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;####################&quot;</span>);</span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">&quot;F:\\IdeaProjects\\javacourse&quot;</span>);</span><br><span class="line"></span><br><span class="line">String[] listString = file.list();</span><br><span class="line"><span class="keyword">for</span> (String s : listString) &#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">.idea</span></span><br><span class="line"><span class="comment">day0104</span></span><br><span class="line"><span class="comment">day0105</span></span><br><span class="line"><span class="comment">hs_err_pid14392.log</span></span><br><span class="line"><span class="comment">hs_err_pid20936.log</span></span><br><span class="line"><span class="comment">hs_err_pid6436.log</span></span><br><span class="line"><span class="comment">io</span></span><br><span class="line"><span class="comment">javacourse.iml</span></span><br><span class="line"><span class="comment">out</span></span><br><span class="line"><span class="comment">src</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">File[] files = file.listFiles();</span><br><span class="line"><span class="keyword">for</span> (File f : files) &#123;</span><br><span class="line">    System.out.println(f);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">F:\IdeaProjects\javacourse\.idea</span></span><br><span class="line"><span class="comment">F:\IdeaProjects\javacourse\day0104</span></span><br><span class="line"><span class="comment">F:\IdeaProjects\javacourse\day0105</span></span><br><span class="line"><span class="comment">F:\IdeaProjects\javacourse\hs_err_pid14392.log</span></span><br><span class="line"><span class="comment">F:\IdeaProjects\javacourse\hs_err_pid20936.log</span></span><br><span class="line"><span class="comment">F:\IdeaProjects\javacourse\hs_err_pid6436.log</span></span><br><span class="line"><span class="comment">F:\IdeaProjects\javacourse\io</span></span><br><span class="line"><span class="comment">F:\IdeaProjects\javacourse\javacourse.iml</span></span><br><span class="line"><span class="comment">F:\IdeaProjects\javacourse\out</span></span><br><span class="line"><span class="comment">F:\IdeaProjects\javacourse\src</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h2 id="重命名功能"><a href="#重命名功能" class="headerlink" title="重命名功能"></a>重命名功能</h2><ul>
<li><strong>renameTo(File dest)：</strong>把文件重命名为指定的文件路径<ul>
<li>返回true，需要保证file1在硬盘里是存在的，file2在硬件里是不存在的；</li>
<li>相当于移动文件。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File file1 = <span class="keyword">new</span> File(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">File file2 = <span class="keyword">new</span> File(<span class="string">&quot;F:\\IdeaProjects\\javacourse\\io\\hi.txt&quot;</span>);</span><br><span class="line"><span class="keyword">boolean</span> b = file1.renameTo(file2);</span><br><span class="line">System.out.println(b);</span><br></pre></td></tr></table></figure>
<h2 id="判断功能"><a href="#判断功能" class="headerlink" title="判断功能"></a>判断功能</h2><ul>
<li><strong>isDirectory()：</strong>判断是否是文件目录</li>
<li><strong>isFile()：</strong>判断是否是文件</li>
<li><strong>exists()：</strong>判断是否存在</li>
<li><strong>canRead()：</strong>判断是否可读</li>
<li><strong>canWrite()：</strong>判断是否可写</li>
<li><strong>isHidden()：</strong>判断是否隐藏</li>
</ul>
<p>针对文件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">&quot;F:\\IdeaProjects\\javacourse\\io\\hi.txt&quot;</span>);</span><br><span class="line">System.out.println(file.isDirectory());<span class="comment">//false</span></span><br><span class="line">System.out.println(file.isFile());<span class="comment">//true</span></span><br><span class="line">System.out.println(file.exists());<span class="comment">//true</span></span><br><span class="line">System.out.println(file.canRead());<span class="comment">//true</span></span><br><span class="line">System.out.println(file.canWrite());<span class="comment">//true</span></span><br><span class="line">System.out.println(file.isHidden());<span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p>针对文件夹：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">&quot;F:\\IdeaProjects\\javacourse\\io&quot;</span>);</span><br><span class="line">System.out.println(file.isDirectory());<span class="comment">//true</span></span><br><span class="line">System.out.println(file.isFile());<span class="comment">//false</span></span><br><span class="line">System.out.println(file.exists());<span class="comment">//true</span></span><br><span class="line">System.out.println(file.canRead());<span class="comment">//true</span></span><br><span class="line">System.out.println(file.canWrite());<span class="comment">//true</span></span><br><span class="line">System.out.println(file.isHidden());<span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<h2 id="File类的创建功能"><a href="#File类的创建功能" class="headerlink" title="File类的创建功能"></a>File类的创建功能</h2><ul>
<li><strong>createNewFile()：</strong>创建文件。若文件存在，则不创建，返回false；</li>
<li><strong>mkdir()：</strong>创建文件目录。若此文件目录存在，则不创建了，如果此文件目录的上层目录不存在，不予创建；</li>
<li><strong>mkdirs()：</strong>创建文件目录。若上层文件目录不存在，则一并创建；</li>
<li><strong>delete()：</strong>删除文件/文件目录。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>IO流</category>
      </categories>
      <tags>
        <tag>IO流</tag>
        <tag>File类</tag>
      </tags>
  </entry>
  <entry>
    <title>Java比较器</title>
    <url>/p/32876.html</url>
    <content><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>Java中的对象，在正常的情况下只能使用“==”、“！=”来比较地址值，而不能使用“&gt;”、“&lt;”。但是在开发过程中，我们需要对多个对象不同的属性进行排序，这就需要比较对象之间的大小。比如，淘宝搜索某商品，会呈现一个综合排序，我们可以根据销量、好评等进行再次排序。</p>
<a id="more"></a>

<h2 id="Comparable接口"><a href="#Comparable接口" class="headerlink" title="Comparable接口"></a>Comparable接口</h2><ul>
<li>该接口对实现它的每个类的对象强加一个整体排序。这个排序被称为类的<em>自然排序</em> ，类的<code>compareTo</code>方法被称为其<em>自然比较方法</em> 。</li>
<li>String、包装类等实现了Comparable接口，重写了compareTo(obj)方法，给出了比较两个对象大小的方法。</li>
<li>重写compareTo(obj)方法的规则：如果当前的对象this大于形参obj，返回正整数；如果当前对象this小于形参obj，返回负整数；如果相等返回0。</li>
<li>默认从小到大排序。</li>
<li><a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/Collections.html#sort-java.util.List-"><code>Collections.sort</code></a> （和<a href="https://www.matools.com/file/manual/jdk_api_1.8_google/java/util/Arrays.html#sort-java.lang.Object:A-"><code>Arrays.sort</code></a> ）可以自动对实现此接口的对象进行列表（和数组）排序。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String[] arr1 = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;pencil&quot;</span>,<span class="string">&quot;pen&quot;</span>,<span class="string">&quot;eraser&quot;</span>,<span class="string">&quot;computer&quot;</span>,<span class="string">&quot;mouse&quot;</span>,<span class="string">&quot;ipad&quot;</span>&#125;;</span><br><span class="line">    Arrays.sort(arr1);</span><br><span class="line">    System.out.println(Arrays.toString(arr1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[computer, eraser, ipad, mouse, pen, pencil]</span><br></pre></td></tr></table></figure>
<h2 id="自定义类实现Comparable接口"><a href="#自定义类实现Comparable接口" class="headerlink" title="自定义类实现Comparable接口"></a>自定义类实现Comparable接口</h2><p>自定义类想要排序需要实现Comparable接口，重写compareTo()方法，在该方法中指明如何排序。不然会报错：java.lang.ClassCastException。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Goods</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Goods</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Goods</span><span class="params">(String name, <span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Goods o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.price &gt; o.price)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">this</span>.price &lt; o.price)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name.compareTo(o.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GoodsTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Goods[] arr = <span class="keyword">new</span> Goods[<span class="number">5</span>];</span><br><span class="line">    arr[<span class="number">0</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;philips&quot;</span>, <span class="number">1000</span>);</span><br><span class="line">    arr[<span class="number">1</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;lenovo&quot;</span>, <span class="number">2000</span>);</span><br><span class="line">    arr[<span class="number">2</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;apple&quot;</span>, <span class="number">6000</span>);</span><br><span class="line">    arr[<span class="number">3</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;sony&quot;</span>, <span class="number">3000</span>);</span><br><span class="line">    arr[<span class="number">4</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;huawei&quot;</span>, <span class="number">5000</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;排序前：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (Goods goods: arr)&#123;</span><br><span class="line">        System.out.println(goods.getName() + <span class="string">&quot;:&quot;</span> + goods.getPrice());</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(arr);</span><br><span class="line">    System.out.println(<span class="string">&quot;排序后：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (Goods goods: arr)&#123;</span><br><span class="line">        System.out.println(goods.getName() + <span class="string">&quot;:&quot;</span> + goods.getPrice());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">排序前：</span><br><span class="line">philips:<span class="number">1000.0</span></span><br><span class="line">lenovo:<span class="number">2000.0</span></span><br><span class="line">apple:<span class="number">6000.0</span></span><br><span class="line">sony:<span class="number">3000.0</span></span><br><span class="line">huawei:<span class="number">5000.0</span></span><br><span class="line">排序后：</span><br><span class="line">philips:<span class="number">1000.0</span></span><br><span class="line">lenovo:<span class="number">2000.0</span></span><br><span class="line">sony:<span class="number">3000.0</span></span><br><span class="line">huawei:<span class="number">5000.0</span></span><br><span class="line">apple:<span class="number">6000.0</span></span><br></pre></td></tr></table></figure>
<h2 id="Comparator接口"><a href="#Comparator接口" class="headerlink" title="Comparator接口"></a>Comparator接口</h2><ul>
<li><strong>定制排序</strong>：当元素的类型没有实现java.lang.Comparable接口而又不方便修改代码，或者实现了java.lang.Comparable接口的排序规则不适合当前的操作，考虑使用Comparator接口。</li>
<li>重写int compare(T o1, T o2)方法，比较o1和o2的大小，如果返回正整数，则o1&gt;o2；如果返回负整数，则o1&lt;o2；如果返回0，则相等。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    String[] arr1 = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;pencil&quot;</span>,<span class="string">&quot;pen&quot;</span>,<span class="string">&quot;eraser&quot;</span>,<span class="string">&quot;computer&quot;</span>,<span class="string">&quot;mouse&quot;</span>,<span class="string">&quot;ipad&quot;</span>&#125;;</span><br><span class="line">    Arrays.sort(arr1,</span><br><span class="line">            <span class="keyword">new</span> Comparator()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (o1 <span class="keyword">instanceof</span> String &amp;&amp; o2 <span class="keyword">instanceof</span> String)&#123;</span><br><span class="line">                        String s1 = (String) o1;</span><br><span class="line">                        String s2 = (String) o2;</span><br><span class="line">                        <span class="keyword">return</span> -s1.compareTo(s2);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;输入类型不一致&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">    System.out.println(Arrays.toString(arr1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">[pencil, pen, mouse, ipad, eraser, computer]</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Goods[] arr = <span class="keyword">new</span> Goods[<span class="number">6</span>];</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;philips&quot;</span>, <span class="number">1000</span>);</span><br><span class="line">        arr[<span class="number">1</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;lenovo&quot;</span>, <span class="number">2000</span>);</span><br><span class="line">        arr[<span class="number">2</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;apple&quot;</span>, <span class="number">6000</span>);</span><br><span class="line">        arr[<span class="number">3</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;sony&quot;</span>, <span class="number">3000</span>);</span><br><span class="line">        arr[<span class="number">4</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;huawei&quot;</span>, <span class="number">5000</span>);</span><br><span class="line">        arr[<span class="number">5</span>] = <span class="keyword">new</span> Goods(<span class="string">&quot;huawei&quot;</span>, <span class="number">8000</span>);</span><br><span class="line">        Arrays.sort(arr,</span><br><span class="line">                <span class="keyword">new</span> Comparator()&#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> (o1 <span class="keyword">instanceof</span> Goods &amp;&amp; o2 <span class="keyword">instanceof</span> Goods)&#123;</span><br><span class="line">                            Goods g1 = (Goods) o1;</span><br><span class="line">                            Goods g2 = (Goods) o2;</span><br><span class="line">                            <span class="keyword">if</span> (g1.getName().equals(g2.getName()))&#123;</span><br><span class="line">                                <span class="keyword">return</span> -Double.compare(g1.getPrice(),g2.getPrice());</span><br><span class="line">                            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                                <span class="keyword">return</span> g1.getName().compareTo(g2.getName());</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">        <span class="keyword">for</span> (Goods goods: arr)&#123;</span><br><span class="line">            System.out.println(goods.getName() + <span class="string">&quot;:&quot;</span> + goods.getPrice());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">apple:<span class="number">6000.0</span></span><br><span class="line">huawei:<span class="number">8000.0</span></span><br><span class="line">huawei:<span class="number">5000.0</span></span><br><span class="line">lenovo:<span class="number">2000.0</span></span><br><span class="line">philips:<span class="number">1000.0</span></span><br><span class="line">sony:<span class="number">3000.0</span></span><br></pre></td></tr></table></figure>
<h1 id="Comparable和Comparator区别和联系"><a href="#Comparable和Comparator区别和联系" class="headerlink" title="Comparable和Comparator区别和联系"></a>Comparable和Comparator区别和联系</h1><ul>
<li>Comparable是排序接口，若一个类实现了Comparable接口，就意味着“该类支持排序”。而Comparator是比较器，我们若需要控制某个类的次序，可以建立一个“该类的比较器”来进行排序。</li>
<li>Comparable接口的方式一旦确定，保证Comparable接口实现类的对象在任何位置都可以比较大小；Comparator接口属于临时性比较。</li>
<li>Comparable相当于“内部比较器”，而Comparator相当于“外部比较器”。</li>
<li>两种方法各有优劣， 用Comparable 简单， 只要实现Comparable 接口的对象直接就成为一个可以比较的对象，但是需要修改源代码。 用Comparator 的好处是不需要修改源代码， 而是另外实现一个比较器， 当某个自定义的对象需要作比较的时候，把比较器和对象一起传递过去就可以比大小了， 并且在Comparator 里面用户可以自己实现复杂的可以通用的逻辑，使其可以匹配一些比较简单的对象，那样就可以节省很多重复劳动了。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
        <category>比较器</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>比较器</tag>
      </tags>
  </entry>
  <entry>
    <title>StringBuffer和StringBuilder</title>
    <url>/p/31461.html</url>
    <content><![CDATA[<h3 id="StringBuffer、StringBuilder和String的异同？"><a href="#StringBuffer、StringBuilder和String的异同？" class="headerlink" title="StringBuffer、StringBuilder和String的异同？"></a>StringBuffer、StringBuilder和String的异同？</h3><a id="more"></a>

<p><strong>异：</strong></p>
<ul>
<li>String：①不可变的字符序列；</li>
<li>StringBuffer：①可变的字符序列；②线程安全的，效率较低；</li>
<li>StringBuilder：①可变字符序列；②线程不安全，效率较高；</li>
</ul>
<p><strong>同：</strong></p>
<p>三者底层都是用char[]存储。</p>
<p><strong>效率对比：StringBuilder &gt; StringBuffer &gt; String</strong></p>
<p><strong>问</strong>：为什么都是使用char[]存储，StringBuffer和StringBuilder是可变的字符序列？</p>
<p><strong>答</strong>：源码分析如下：</p>
<p>对于String：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String();<span class="comment">//相当于new char[0];</span></span><br><span class="line">String str1 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);<span class="comment">//相当于new char[]&#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;&#125;;</span></span><br></pre></td></tr></table></figure>
<p>对于StringBuffer或者StringBuilder：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuffer sb1 = <span class="keyword">new</span> StringBuffer();<span class="comment">//相当于new char[16];底层创建了一个长度是16的空字符数组</span></span><br><span class="line">sb1.append(<span class="string">&#x27;a&#x27;</span>);<span class="comment">//相当于value[0]=&#x27;a&#x27;;</span></span><br><span class="line">sb1.append(<span class="string">&#x27;b&#x27;</span>);<span class="comment">//相当于value[0]=&#x27;b&#x27;;</span></span><br><span class="line">sb1.append(<span class="string">&#x27;c&#x27;</span>);<span class="comment">//相当于value[0]=&#x27;c&#x27;;</span></span><br></pre></td></tr></table></figure>
<p>查看StringBuffer的空参构造器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a string buffer with no characters in it and an</span></span><br><span class="line"><span class="comment"> * initial capacity of 16 characters.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(<span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>点击super查看父类的构造器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates an AbstractStringBuilder of the specified capacity.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">AbstractStringBuilder(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">    value = <span class="keyword">new</span> <span class="keyword">char</span>[capacity];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>发现</strong>：StringBuffer在创建字符串的时候，哪怕是调用空参构造器，也会预留一个大小为16的char型数组，所以后续往字符串中添加字符/字符串的时候，会直接在已有的char型数组上添加，即可变序列；</p>
<p>如果调用非空构造器，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuffer sb2 = <span class="string">&quot;abc&quot;</span>;<span class="comment">//相当于new char[16+sb2.length];</span></span><br></pre></td></tr></table></figure>
<p>查看非空构造器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a string buffer initialized to the contents of the</span></span><br><span class="line"><span class="comment"> * specified string. The initial capacity of the string buffer is</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> 16&#125; plus the length of the string argument.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   str   the initial contents of the buffer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StringBuffer</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(str.length() + <span class="number">16</span>);</span><br><span class="line">    append(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>发现：</strong>调用非空构造器的时候，会初始化一个当前字符数组长度+16大小的char型数组，然后将字符一一append进去。</p>
<p><strong>问：</strong>sb1和sb2长度是多少？</p>
<p><strong>答：</strong>0和3.</p>
<p><strong>问：</strong>扩容问题：如果要添加的数据底层数组盛不下了，那么需要扩容底层的数组。</p>
<p><strong>答：</strong>默认情况下扩容为原来容量的2倍+2，同时将原有数组中的元素复制到新的数组中。</p>
<p>StringBuffer中append方法的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    toStringCache = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是使用了父类中的append方法，则父类AbstractStringBuilder中append方法的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AbstractStringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> appendNull();</span><br><span class="line">    <span class="keyword">int</span> len = str.length();</span><br><span class="line">    ensureCapacityInternal(count + len);</span><br><span class="line">    str.getChars(<span class="number">0</span>, len, value, count);</span><br><span class="line">    count += len;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中ensureCapacityInternal()方法中count是当前数组中已有的数组长度，len是新添加的字符串的长度。ensureCapacityInternal()方法的源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minimumCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minimumCapacity - value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        value = Arrays.copyOf(value,</span><br><span class="line">                newCapacity(minimumCapacity));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果现有的数组长度+要添加的字符串长度&gt;现在的value长度，那么创建一个新的容量的数组，并将数组元素复制过去。</p>
<p>newCapacity()方法源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">newCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = (value.length &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (newCapacity &lt;= <span class="number">0</span> || MAX_ARRAY_SIZE - newCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        ? hugeCapacity(minCapacity)</span><br><span class="line">        : newCapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见，创建的新的char型数组长度为数组长度的2倍+2。如果还是不能满足需求，则直接将数组长度作为底层value的容量。</p>
<p><strong>注：</strong>开发中如果频繁修改字符串，String的效率最低；但是在StringBuffer中如果频繁修改，频繁扩容，append，也不是很好，所以开发中可以考虑使用StringBuffer(int capacity)或者StringBuilder(int capacity)直接确定char型数组容量来构建字符串。</p>
<h3 id="StringBuffer中的常用方法"><a href="#StringBuffer中的常用方法" class="headerlink" title="StringBuffer中的常用方法"></a>StringBuffer中的常用方法</h3><ul>
<li>字符串拼接</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">StringBuffer <span class="title">append</span><span class="params">(xxx)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>删除指定位置的内容</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">delete</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>把[start，end)位置替换为str</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">replace</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end, String str)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>在指定位置插入xxx</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">insert</span><span class="params">(<span class="keyword">int</span> offset, xxx)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>反转</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">reverse</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>返回一个从start开始，到end索引结束的子字符串</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> CharSequence <span class="title">subSequence</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>返回指定索引值的元素</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>修改指定索引值的元素</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setCharAt</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">char</span> ch)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>返回指定字符串在此字符串中第一次出现的索引值</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str)</span></span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
        <category>String类</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>String类与其他结构之间的转换</title>
    <url>/p/37668.html</url>
    <content><![CDATA[<h3 id="String类与其他结构之间的转换"><a href="#String类与其他结构之间的转换" class="headerlink" title="String类与其他结构之间的转换"></a>String类与其他结构之间的转换</h3><h4 id="String与基本数据类型、包装类之间的转换"><a href="#String与基本数据类型、包装类之间的转换" class="headerlink" title="String与基本数据类型、包装类之间的转换"></a>String与基本数据类型、包装类之间的转换</h4><a id="more"></a>

<h5 id="String类-–-gt-基本数据类型、包装类："><a href="#String类-–-gt-基本数据类型、包装类：" class="headerlink" title="String类 –&gt; 基本数据类型、包装类："></a>String类 –&gt; 基本数据类型、包装类：</h5><p><strong>调用包装类的静态方法：parseXxx(str)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest3</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="comment">//        int num = (int) s1;//error</span></span><br><span class="line">        <span class="keyword">int</span> b1 = Integer.parseInt(s1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="基本数据类型、包装类-–-gt-String类："><a href="#基本数据类型、包装类-–-gt-String类：" class="headerlink" title="基本数据类型、包装类 –&gt; String类："></a>基本数据类型、包装类 –&gt; String类：</h5><p><strong>调用String重载的valueOf(xxx)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//两种都可以</span></span><br><span class="line">String c1 = String.valueOf(b1);</span><br><span class="line">String c2 = b1 + <span class="string">&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>
<h4 id="String与字符数组转换"><a href="#String与字符数组转换" class="headerlink" title="String与字符数组转换"></a>String与字符数组转换</h4><h5 id="String-–-gt-char-："><a href="#String-–-gt-char-：" class="headerlink" title="String –&gt; char[]："></a>String –&gt; char[]：</h5><p><strong>调用String中的toCharArray()方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String s1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="keyword">char</span>[] c1 = s1.toCharArray();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; c1.length; i++) &#123;</span><br><span class="line">        System.out.println(c1[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="char-–-gt-String："><a href="#char-–-gt-String：" class="headerlink" title="char[] –&gt; String："></a>char[] –&gt; String：</h5><p><strong>调用String的构造器</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> [] arr1 = <span class="keyword">new</span> <span class="keyword">char</span>[] &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">String s2 = <span class="keyword">new</span> String(arr1);</span><br><span class="line">System.out.println(s2);</span><br></pre></td></tr></table></figure>
<h4 id="String与字节数组转换"><a href="#String与字节数组转换" class="headerlink" title="String与字节数组转换"></a>String与字节数组转换</h4><h5 id="String-–-gt-byte-："><a href="#String-–-gt-byte-：" class="headerlink" title="String –&gt; byte[]："></a>String –&gt; byte[]：</h5><p><strong>调用String的getBytes()方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String s1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="keyword">byte</span>[] bytes = s1.getBytes();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bytes.length; i++) &#123;</span><br><span class="line">        System.out.println(bytes[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="byte-–-gt-String："><a href="#byte-–-gt-String：" class="headerlink" title="byte[] –&gt; String："></a>byte[] –&gt; String：</h5><p><strong>调用String的构造器</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s2 = <span class="keyword">new</span> String(bytes);</span><br><span class="line">System.out.println(s2);</span><br></pre></td></tr></table></figure>
<p><strong>注</strong>：String与字节数组转换可以看作一个编解码的过程，在此过程中，必须保证使用的字符集相同，否则会出现乱码。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
        <category>String类</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>String类常用方法总结</title>
    <url>/p/7009.html</url>
    <content><![CDATA[<h3 id="String类常用方法："><a href="#String类常用方法：" class="headerlink" title="String类常用方法："></a>String类常用方法：</h3><a id="more"></a>

<ul>
<li>返回字符串的长度：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>判断是否是空字符串：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value.length == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>返回某索引处的字符：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((index &lt; <span class="number">0</span>) || (index &gt;= value.length)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用默认语言环境，将String中的所有字符转换为小写：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toLowerCase</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>使用s1.toLowerCase()是重新创建一个字符串，并非修改s1，体现了String的不可变性。</p>
<ul>
<li>使用默认语言环境，将String中的所有字符转换为大写：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toUpperCase</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>返回字符串的副本，忽略前导空白和尾部空白（可以用于用户名）：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">trim</span><span class="params">()</span> </span></span><br></pre></td></tr></table></figure>
<ul>
<li>比较字符串的内容是否相同：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        String anotherString = (String)anObject;</span><br><span class="line">        <span class="keyword">int</span> n = value.length;</span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            <span class="keyword">char</span> v1[] = value;</span><br><span class="line">            <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>源码解读：</strong>如果两个字符串中所存的地址值相等，那么两个字符串一定相同，返回true；如果对比的字符串是String的一个实例，且两个字符串长度相等，那么逐一比较，一旦有一个不相等，就返回false；如果两个字符串所存的地址值不相等，且长度也不相等，那么返回false。</p>
<ul>
<li>与equals方法类似，忽略大小写：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equalsIgnoreCase</span><span class="params">(String anotherString)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">this</span> == anotherString) ? <span class="keyword">true</span></span><br><span class="line">                : (anotherString != <span class="keyword">null</span>)</span><br><span class="line">                &amp;&amp; (anotherString.value.length == value.length)</span><br><span class="line">                &amp;&amp; regionMatches(<span class="keyword">true</span>, <span class="number">0</span>, anotherString, <span class="number">0</span>, value.length);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>将指定字符串连接到此字符串的结尾，等价于用“+”:</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concat</span><span class="params">(String str)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>比较字符串大小：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String anotherString)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = value.length;</span><br><span class="line">    <span class="keyword">int</span> len2 = anotherString.value.length;</span><br><span class="line">    <span class="keyword">int</span> lim = Math.min(len1, len2);</span><br><span class="line">    <span class="keyword">char</span> v1[] = value;</span><br><span class="line">    <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; lim) &#123;</span><br><span class="line">        <span class="keyword">char</span> c1 = v1[k];</span><br><span class="line">        <span class="keyword">char</span> c2 = v2[k];</span><br><span class="line">        <span class="keyword">if</span> (c1 != c2) &#123;</span><br><span class="line">            <span class="keyword">return</span> c1 - c2;</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len1 - len2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>源码解读：</strong>如果是负数，则当前字符串小；如果是0，则两个字符串大小相等；如果是正数，则当前字符串大。</p>
<ul>
<li>返回一个新的字符串，它是此字符串的从beginIndex开始截取的：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (beginIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(beginIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> subLen = value.length - beginIndex;</span><br><span class="line">    <span class="keyword">if</span> (subLen &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(subLen);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (beginIndex == <span class="number">0</span>) ? <span class="keyword">this</span> : <span class="keyword">new</span> String(value, beginIndex, subLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>返回一个新的字符串，它是此字符串从beginIndex开始截取到endIndex（不包含endIndex）：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (beginIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(beginIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (endIndex &gt; value.length) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(endIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> subLen = endIndex - beginIndex;</span><br><span class="line">    <span class="keyword">if</span> (subLen &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> StringIndexOutOfBoundsException(subLen);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ((beginIndex == <span class="number">0</span>) &amp;&amp; (endIndex == value.length)) ? <span class="keyword">this</span></span><br><span class="line">            : <span class="keyword">new</span> String(value, beginIndex, subLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注：</strong>“左闭右开”</p>
<ul>
<li>测试此字符串是否是以指定的后缀结束：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">endsWith</span><span class="params">(String suffix)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>测试此字符串是否以指定的前缀开始：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix, <span class="keyword">int</span> toffset)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>当且仅当此字符串包含指定的char值序列时，返回true：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(CharSequence s)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>返回指定字符串在此字符串中第一次出现处的索引：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str)</span></span></span><br></pre></td></tr></table></figure>
<p><strong>注：</strong>如果此字符串中不存在指定字符串，则返回-1.</p>
<ul>
<li>从指定位置开始返回指定字符串在此字符串中第一次出现处的索引：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(String str, <span class="keyword">int</span> fromIndex)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>返回指定字符串在此字符串中最右边出现处的索引：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(String str)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(String str, <span class="keyword">int</span> fromIndex)</span></span></span><br></pre></td></tr></table></figure>
<p><strong>注：</strong>什么时候indexOf(str)和lastIndexOf(str)返回值相同？</p>
<p>①存在唯一的一个str；</p>
<p>②不存在str。</p>
<ul>
<li>返回一个字符串，它是通过用newChar替换此字符串中出现的所有oldChar得到的：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replace</span><span class="params">(<span class="keyword">char</span> oldChar, <span class="keyword">char</span> newChar)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用指定的字面值替换序列中的指定字符串：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replace</span><span class="params">(CharSequence target, CharSequence replacement)</span></span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
        <category>String类</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>String类的创建和拼接</title>
    <url>/p/52765.html</url>
    <content><![CDATA[<h3 id="String类：字符串"><a href="#String类：字符串" class="headerlink" title="String类：字符串"></a><strong>String类：字符串</strong></h3><a id="more"></a>

<p><img src="/p/Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201222113310973.png" alt="image-20201222113310973"></p>
<ul>
<li><p>String是一个final类，代表<strong>不可变</strong>的字符序列；</p>
</li>
<li><p>字符串是常量，用双引号引起来表示，它们的值在创建之后不能更改；</p>
</li>
<li><p>String对象的字符内容是存储在一个字符数组value[]中的；</p>
</li>
<li><p>String实现了Serializable接口：表示字符串支持序列化；</p>
</li>
<li><p>String实现了Comparable接口：表示可以比较大小；</p>
</li>
<li><p>String实现了CharSequence接口</p>
</li>
</ul>
<p><strong>注：</strong></p>
<p>通过<strong>字面量的方式</strong>给一个字符串赋值，此时的字符串值声明在<strong>字符串常量池</strong>中。</p>
<p>字符串常量池中是<strong>不会存储相同内容的字符串</strong>。</p>
<p><strong>不可变性：</strong></p>
<ul>
<li>当前字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value进行赋值；</li>
<li>当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能在原有的value进行赋值；</li>
<li>当调用String的replace方法修改指定的字符或者字符串时，也需要重新指定内存区域赋值，不能在原有的value进行赋值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest1</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String s1 = <span class="string">&quot;abc&quot;</span>;<span class="comment">//字面量</span></span><br><span class="line">        String s2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">        System.out.println(<span class="string">&quot;#####################&quot;</span>);</span><br><span class="line"></span><br><span class="line">        s1 = <span class="string">&quot;hi&quot;</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(s1);</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">        System.out.println(<span class="string">&quot;#####################&quot;</span>);</span><br><span class="line"></span><br><span class="line">        String s3 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        s3 += <span class="string">&quot;def&quot;</span>;</span><br><span class="line">        System.out.println(s3);</span><br><span class="line">        System.out.println(s3 == s2);</span><br><span class="line">        System.out.println(<span class="string">&quot;#####################&quot;</span>);</span><br><span class="line"></span><br><span class="line">        String s4 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        String s5 = s4.replace(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;m&#x27;</span>);</span><br><span class="line">        System.out.println(s4);</span><br><span class="line">        System.out.println(s5);</span><br><span class="line">        System.out.println(s5 == s4);</span><br><span class="line">        System.out.println(<span class="string">&quot;#####################&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">true</span></span><br><span class="line">#####################</span><br><span class="line">hi</span><br><span class="line">abc</span><br><span class="line"><span class="keyword">false</span></span><br><span class="line">#####################</span><br><span class="line">abcdef</span><br><span class="line"><span class="keyword">false</span></span><br><span class="line">#####################</span><br><span class="line">abc</span><br><span class="line">mbc</span><br><span class="line"><span class="keyword">false</span></span><br><span class="line">#####################</span><br></pre></td></tr></table></figure>
<h3 id="String对象的创建："><a href="#String对象的创建：" class="headerlink" title="String对象的创建："></a>String对象的创建：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String s1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><strong>两种创建方式的区别：</strong></p>
<p>String s1 = “abc”;//声明在方法区的字符串常量池中。</p>
<p>String s2 = new String(“abc”);//此时保存的地址值，是数据在堆空间中开辟空间以后对应的地址值。</p>
<p>s1 == s2;//false</p>
<p><strong>两种创建方式的联系：</strong></p>
<p>s1保存的地址是在字符串常量池中创建的字符串地址，s2保存的地址是在堆中开辟空间以后对应的地址值，但是String的本质是字符数组，所以在堆中的字符数组所保存的地址是和s1保存的地址值相同的，均是常量池里的那个地址。</p>
<p><img src="/p/Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201222155242960.png" alt="image-20201222155242960"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String s1 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        String s2 = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"></span><br><span class="line">        String s3 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        String s4 = <span class="keyword">new</span> String(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">        System.out.println(s1 == s3);</span><br><span class="line">        System.out.println(s3 == s4);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;#########################################################&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(<span class="string">&quot;Tom&quot;</span>, <span class="number">45</span>);</span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person(<span class="string">&quot;Tom&quot;</span>, <span class="number">45</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(p1.name.equals(p2.name));<span class="comment">//true</span></span><br><span class="line">        System.out.println(p1.name == p2.name);<span class="comment">//true</span></span><br><span class="line">        System.out.println(p1 == p2);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>问：</strong>String s = new String(“abc”);这种方式创造对象，在内存中创建了几个对象？</p>
<p><strong>答：</strong>2个。1个是堆空间的new结构，另1个是char[]对应的常量池中的数据：“abc”。</p>
<h3 id="String类中不同的拼接方式："><a href="#String类中不同的拼接方式：" class="headerlink" title="String类中不同的拼接方式："></a>String类中不同的拼接方式：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTest2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        String s2 = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">        String s3 = <span class="string">&quot;helloworld&quot;</span>;</span><br><span class="line">        String s4 = <span class="string">&quot;hello&quot;</span> + <span class="string">&quot;world&quot;</span>;</span><br><span class="line">        String s5 = s1 + <span class="string">&quot;world&quot;</span>;</span><br><span class="line">        String s6 = <span class="string">&quot;hello&quot;</span> + s2;</span><br><span class="line">        String s7 = s1 + s2;</span><br><span class="line">        String s8 = s5.intern();</span><br><span class="line"></span><br><span class="line">        System.out.println(s3 == s4);<span class="comment">//true</span></span><br><span class="line">        System.out.println(s3 == s5);<span class="comment">//false</span></span><br><span class="line">        System.out.println(s3 == s6);<span class="comment">//false</span></span><br><span class="line">        System.out.println(s3 == s7);<span class="comment">//false</span></span><br><span class="line">        System.out.println(s5 == s6);<span class="comment">//false</span></span><br><span class="line">        System.out.println(s5 == s7);<span class="comment">//false</span></span><br><span class="line">        System.out.println(s6 == s7);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">        System.out.println(s3 == s8);<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>常量和常量的拼接结果在常量池，并且常量池中不会存在相同内容的常量；</li>
<li>只要其中有一个是变量，结果就在堆中；</li>
<li>如果拼接的结果调用intern()方法，返回值就在常量池中。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
        <category>String类</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>反射</title>
    <url>/p/53772.html</url>
    <content><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><ul>
<li>Reflection(反射)是被视为动态语言的关键，反射机制允许程序再执行期间借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性和方法。</li>
<li>Java反射机制提供的功能：<ul>
<li>在运行时判断任意一个对象所属的类</li>
<li>在运行时构造任意一个类的对象</li>
<li>在运行时判断任意一个类所具有的成员变量和方法</li>
<li>在运行时获取泛型信息</li>
<li>在运行时调用任意一个对象的成员变量和方法</li>
<li>在运行时处理注解</li>
<li>生成动态代理</li>
</ul>
</li>
</ul>
<a id="more"></a> 

<h1 id="反射举例"><a href="#反射举例" class="headerlink" title="反射举例"></a>反射举例</h1><ul>
<li>在类的外部，是不能通过类的对象调用其内部私有结构的；</li>
<li>通过反射可以调用类的私有结构。比如私有的构造器、方法、属性。</li>
</ul>
<p>Person类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我是一个人&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">showNation</span><span class="params">(String nation)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我的国籍是&quot;</span> + nation);</span><br><span class="line">        <span class="keyword">return</span> nation;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="反射之前："><a href="#反射之前：" class="headerlink" title="反射之前："></a>反射之前：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//反射之前</span></span><br><span class="line">    System.out.println(<span class="string">&quot;反射之前&quot;</span>);</span><br><span class="line">    <span class="comment">//1.创建Person类对象</span></span><br><span class="line">    Person p1 = <span class="keyword">new</span> Person(<span class="string">&quot;Tom&quot;</span>, <span class="number">3</span>);</span><br><span class="line">    <span class="comment">//2.通过对象，调用其内部属性、方法</span></span><br><span class="line">    p1.age = <span class="number">30</span>;</span><br><span class="line">    System.out.println(p1);</span><br><span class="line"></span><br><span class="line">    p1.show();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">反射之前</span><br><span class="line">Person&#123;name=<span class="string">&#x27;Tom&#x27;</span>, age=<span class="number">30</span>&#125;</span><br><span class="line">我是一个人</span><br></pre></td></tr></table></figure>
<h2 id="反射之后："><a href="#反射之后：" class="headerlink" title="反射之后："></a>反射之后：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchMethodException, NoSuchFieldException </span>&#123;</span><br><span class="line">    <span class="comment">//反射之后</span></span><br><span class="line">    <span class="comment">//1.通过反射，创建Person类的对象</span></span><br><span class="line">    System.out.println(<span class="string">&quot;反射之后&quot;</span>);</span><br><span class="line">    Class clazz = Person.class;</span><br><span class="line">    Constructor cons = clazz.getConstructor(String.class, <span class="keyword">int</span>.class);</span><br><span class="line">    Object obj = cons.newInstance(<span class="string">&quot;Tom&quot;</span>, <span class="number">3</span>);</span><br><span class="line">    Person p = (Person)obj;</span><br><span class="line">    System.out.println(p.toString());</span><br><span class="line">    <span class="comment">//2.通过反射，调用对象指定的属性、方法</span></span><br><span class="line">    <span class="comment">//调用属性</span></span><br><span class="line">    Field age = clazz.getDeclaredField(<span class="string">&quot;age&quot;</span>);</span><br><span class="line">    age.set(p,<span class="number">30</span>);</span><br><span class="line">    System.out.println(p.toString());</span><br><span class="line">    <span class="comment">//调用方法</span></span><br><span class="line">    Method show = clazz.getDeclaredMethod(<span class="string">&quot;show&quot;</span>);</span><br><span class="line">    show.invoke(p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.通过反射，调用对象私有的属性、方法</span></span><br><span class="line">    <span class="comment">//调用私有构造器</span></span><br><span class="line">    Constructor cons1 = clazz.getDeclaredConstructor(String.class);</span><br><span class="line">    cons1.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    Person p1 = (Person) cons1.newInstance(<span class="string">&quot;Rose&quot;</span>);</span><br><span class="line">    System.out.println(p1);</span><br><span class="line">    <span class="comment">//调用私有的属性</span></span><br><span class="line">    Field name = clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">    name.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    name.set(p1,<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">    System.out.println(p1);</span><br><span class="line">    <span class="comment">//调用私有的方法</span></span><br><span class="line">    Method showNation = clazz.getDeclaredMethod(<span class="string">&quot;showNation&quot;</span>,String.class);</span><br><span class="line">    showNation.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    showNation.invoke(p1,<span class="string">&quot;America&quot;</span>);<span class="comment">//相当于p1.showNation(&quot;America&quot;);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">反射之后</span><br><span class="line">Person&#123;name=<span class="string">&#x27;Tom&#x27;</span>, age=<span class="number">3</span>&#125;</span><br><span class="line">Person&#123;name=<span class="string">&#x27;Tom&#x27;</span>, age=<span class="number">30</span>&#125;</span><br><span class="line">我是一个人</span><br><span class="line">Person&#123;name=<span class="string">&#x27;Rose&#x27;</span>, age=<span class="number">0</span>&#125;</span><br><span class="line">Person&#123;name=<span class="string">&#x27;Jack&#x27;</span>, age=<span class="number">0</span>&#125;</span><br><span class="line">我的国籍是America</span><br></pre></td></tr></table></figure>
<h1 id="java-lang-Class类"><a href="#java-lang-Class类" class="headerlink" title="java.lang.Class类"></a>java.lang.Class类</h1><ul>
<li><strong>类的加载过程：</strong></li>
</ul>
<p>程序经过javac.exe命令以后，会生成一个或者多个字节码文件(.class文件)，接着使用java.exe命令对某个字节码文件进行解释运行。相当于将某个字节码文件加载到内存中。加载到内存中的类，成为运行时类，此<strong>运行时类，就作为Class的一个实例</strong>。可以理解为，每一个类也是一个对象，是Class类的一个对象，可以作为Class类的一个实例。</p>
<ul>
<li>加载到内存中的运行时类，会缓存一段时间，在此时间内，可以通过不同的方式获取此运行时类。</li>
</ul>
<h2 id="获取Class类的实例的方式"><a href="#获取Class类的实例的方式" class="headerlink" title="获取Class类的实例的方式"></a>获取Class类的实例的方式</h2><h3 id="方式一：调用运行时类的属性：-class"><a href="#方式一：调用运行时类的属性：-class" class="headerlink" title="方式一：调用运行时类的属性：.class"></a>方式一：调用运行时类的属性：.class</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;Person&gt; clazz = Person.class;</span><br><span class="line">System.out.println(clazz);<span class="comment">//class Person</span></span><br></pre></td></tr></table></figure>
<h3 id="方式二：通过运行时类的对象"><a href="#方式二：通过运行时类的对象" class="headerlink" title="方式二：通过运行时类的对象"></a>方式二：通过运行时类的对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person p1 = <span class="keyword">new</span> Person();</span><br><span class="line">Class clazz = p1.getClass();</span><br><span class="line">System.out.println(clazz);<span class="comment">//class Person</span></span><br></pre></td></tr></table></figure>
<h3 id="方式三：调用Class的静态方法：forName-String-classPath-—使用多"><a href="#方式三：调用Class的静态方法：forName-String-classPath-—使用多" class="headerlink" title="方式三：调用Class的静态方法：forName(String classPath)—使用多"></a>方式三：调用Class的静态方法：forName(String classPath)—使用多</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class clazz = Class.forName(<span class="string">&quot;Person&quot;</span>);</span><br><span class="line">System.out.println(clazz);<span class="comment">//class Person</span></span><br></pre></td></tr></table></figure>
<h3 id="方式四：使用类的加载器：ClassLoader"><a href="#方式四：使用类的加载器：ClassLoader" class="headerlink" title="方式四：使用类的加载器：ClassLoader"></a>方式四：使用类的加载器：ClassLoader</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassLoader classLoader = ReflectionTest.class.getClassLoader();</span><br><span class="line">Class clazz = classLoader.loadClass(<span class="string">&quot;Person&quot;</span>);</span><br><span class="line">System.out.println(clazz);<span class="comment">//class Person</span></span><br></pre></td></tr></table></figure>
<h2 id="哪些类可以有Class对象"><a href="#哪些类可以有Class对象" class="headerlink" title="哪些类可以有Class对象"></a>哪些类可以有Class对象</h2><ol>
<li>class：外部类，成员（成员内部类，静态内部类），局部内部类，匿名内部类</li>
<li>interface：接口</li>
<li>[]：数组</li>
<li>enum：枚举</li>
<li>annotation：注解@interface</li>
<li>primitive type：基本数据类型</li>
<li>void</li>
</ol>
<h1 id="类的加载器ClassLoader"><a href="#类的加载器ClassLoader" class="headerlink" title="类的加载器ClassLoader"></a>类的加载器ClassLoader</h1>]]></content>
      <categories>
        <category>Java</category>
        <category>反射</category>
      </categories>
      <tags>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串反转</title>
    <url>/p/34837.html</url>
    <content><![CDATA[<p><strong>问题：</strong>将一个字符串进行反转。将字符串中指定部分进行反转。比如“abcdefg”反转为“abfedcg”。</p>
<a id="more"></a>

<p><strong>解法一：转换为char[]</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringQ2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;反转前：&quot;</span> + str);</span><br><span class="line">        System.out.println(<span class="string">&quot;全部反转后：&quot;</span> + StringQ2.myReverse(str));</span><br><span class="line">        System.out.println(<span class="string">&quot;部分反转后：&quot;</span> + StringQ2.myReverse(str,<span class="number">1</span>,<span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">myReverse</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span>[] str2arr = str.toCharArray();</span><br><span class="line">            <span class="keyword">int</span> len = str.length();</span><br><span class="line">            <span class="keyword">char</span>[] arr = <span class="keyword">new</span> <span class="keyword">char</span>[len];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">                arr[i] = str2arr[len-i-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            str = <span class="keyword">new</span> String(arr);</span><br><span class="line">            <span class="keyword">return</span> str;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">myReverse</span><span class="params">(String str, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span></span>&#123;</span><br><span class="line">        String strTemp = str.substring(startIndex, endIndex);</span><br><span class="line">        strTemp = myReverse(strTemp);</span><br><span class="line">        str = str.substring(<span class="number">0</span>,startIndex) + strTemp + str.substring(endIndex);</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>①将字符串转换为char[]类型；</p>
<p>②针对需要反转的字符数组，反着存储到新的字符数组里；</p>
<p>③将不需要反转的头和尾再按顺序加上。</p>
<p><strong>解法二：使用String的拼接</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">myReverse1</span><span class="params">(String str, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String strTemp = str.substring(<span class="number">0</span>, startIndex);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = endIndex-<span class="number">1</span>; i &gt;= startIndex; i--) &#123;</span><br><span class="line">            strTemp += str.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        strTemp += str.substring(endIndex);</span><br><span class="line">        <span class="keyword">return</span> strTemp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种解法看起来比解法一要节省内存，但是实际上由于String类的不可变性，每次拼接一个字符都要重新创建一个对象，效率并不高。</p>
<p><strong>解法三：使用StringBuffer/StringBuilder</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">myReverse2</span><span class="params">(String str, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str != <span class="keyword">null</span>)&#123;</span><br><span class="line">        StringBuffer strBuff = <span class="keyword">new</span> StringBuffer(str);</span><br><span class="line">        StringBuffer strBuffTemp = <span class="keyword">new</span> StringBuffer(strBuff.substring(<span class="number">0</span>, startIndex));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = endIndex-<span class="number">1</span>; i &gt;= startIndex; i--) &#123;</span><br><span class="line">            strBuffTemp.append(strBuff.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        strBuffTemp.append(strBuff.substring(endIndex));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(strBuffTemp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">myReverse3</span><span class="params">(String str, <span class="keyword">int</span> startIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str != <span class="keyword">null</span>)&#123;</span><br><span class="line">        StringBuilder strBuil = <span class="keyword">new</span> StringBuilder(str);</span><br><span class="line">        StringBuilder strBuilTemp = <span class="keyword">new</span> StringBuilder(strBuil.substring(<span class="number">0</span>, startIndex));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = endIndex-<span class="number">1</span>; i &gt;= startIndex; i--) &#123;</span><br><span class="line">            strBuilTemp.append(strBuil.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        strBuilTemp.append(strBuil.substring(endIndex));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(strBuilTemp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用StringBuffer或者StringBuilder替换String，StringBuffer是线程安全的，StringBuilder是线程不安全的。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
        <category>String类</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程的创建方式</title>
    <url>/p/24227.html</url>
    <content><![CDATA[<h3 id="多线程的创建方式"><a href="#多线程的创建方式" class="headerlink" title="多线程的创建方式"></a>多线程的创建方式</h3><a id="more"></a>

<h4 id="创建线程的方式一：继承Thread类"><a href="#创建线程的方式一：继承Thread类" class="headerlink" title="创建线程的方式一：继承Thread类"></a>创建线程的方式一：继承Thread类</h4><p><strong>创建步骤：</strong></p>
<ol>
<li>创建一个继承于Thread类的子类；</li>
<li>重写Thread类中的run()方法，将该线程要执行的操作声明在run()中；</li>
<li>创建Thread子类的对象；</li>
<li>通过此对象调用start()方法：启动当前线程；调用当先线程的run()方法。</li>
</ol>
<p><strong>注：</strong></p>
<ol>
<li>启动一个线程，必须使用start()方法，不能调用run()的方式启动线程；</li>
<li>如果再启动一个线程，需要再创建一个Thread子类对象，然后调用start()方法，不能对用一个对象调用多次start()。</li>
</ol>
<h4 id="创建线程的方式二：实现Runnable接口"><a href="#创建线程的方式二：实现Runnable接口" class="headerlink" title="创建线程的方式二：实现Runnable接口"></a>创建线程的方式二：实现Runnable接口</h4><p><strong>创建步骤：</strong></p>
<ol>
<li>创建一个实现Runnable接口的类；</li>
<li>实现类去实现Runnable接口中的抽象方法run()；</li>
<li>创建实现类的对象；</li>
<li>将创建的实现类的对象作为参数，传递到Thread类的构造器中，创建Thread类的对象；</li>
<li>通过Thread类对象调用start()方法启动线程。</li>
</ol>
<p><strong>注：</strong></p>
<ol>
<li>可以使用同一个实现类对象创建多个线程；</li>
<li>相比于创建方式一，优先使用创建方式二，因为①实现的方式没有类的但继承性的局限性；②实现的方式更适合来处理多个线程又共享数据的情况，因为多线程可以使用同一个Runnable实现类对象来创建线程。</li>
</ol>
<p><strong>继承Thread类①和实现Runnable接口②的创建多线程方式有什么区别？</strong></p>
<p>①继承Thread类，并且覆写了Thread类中的run()方法，而Thread类又是Runnable的实现类，又覆写了Runnable接口中的抽象方法run()；</p>
<p>②直接重写了Runnable接口的抽象方法run()，调用Thread类的start()方法启动线程时，Thread类判断然后使用实现类的run()方法。</p>
<h4 id="创建线程的方式三：实现Callable接口（JDK5-0新增）"><a href="#创建线程的方式三：实现Callable接口（JDK5-0新增）" class="headerlink" title="创建线程的方式三：实现Callable接口（JDK5.0新增）"></a>创建线程的方式三：实现Callable接口（JDK5.0新增）</h4><p><strong>与实现Runnable接口方法相比的区别：</strong></p>
<ul>
<li>相比run()方法，可以有返回值；</li>
<li>方法可以抛出异常，被外面的操作捕获，获取异常信息；</li>
<li>支持泛型的返回值；</li>
<li>需要借助FutureTask嘞，比如获取返回结果。</li>
</ul>
<p><strong>创建步骤：</strong></p>
<ol>
<li>创建一个实现Callable的实现类；</li>
<li>实现call()方法，将此线程需要执行的操作声明在call()方法中；</li>
<li>创建Callable接口实现类的对象；</li>
<li>将此Callable接口类对象作为传递到FutureTask构造器中，创建FutureTask的对象；</li>
<li>将FutureTask的对象作为参数传递到Thread类中，创建Thread对象，并调用start()方法；</li>
<li>如果需要返回值，则使用FutureTask.get()返回FutureTask构造器参数Callbable实现类重写的call<br>()方法的返回值；如果不需要返回值，则Callable实现类中重写的call()方法返回null。</li>
</ol>
<p><strong>实现代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumThread</span> <span class="keyword">implements</span> <span class="title">Callable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">            System.out.println(sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">threadCallableTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        NumThread numThread = <span class="keyword">new</span> NumThread();</span><br><span class="line">        FutureTask futureTask = <span class="keyword">new</span> FutureTask(numThread);</span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(futureTask);</span><br><span class="line">        t.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Object sum = futureTask.get();</span><br><span class="line">            System.out.println(sum);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="创建线程的方式四：使用线程池"><a href="#创建线程的方式四：使用线程池" class="headerlink" title="创建线程的方式四：使用线程池"></a>创建线程的方式四：使用线程池</h4><p>经常创建和销毁，使用量特别大的资源，比如并发情况下的线程，对性能影响很大。</p>
<p>考虑提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁，实现重复利用。</p>
<p>这样做的好处是：</p>
<ol>
<li>提高了响应速度（减少了创建新线程的时间）；</li>
<li>降低了资源消耗（重复利用线程池中线程，不需要每次都创建）；</li>
<li>便于线程管理（设置核心池大小corePollSize，最大线程数maximumPoolSize，线程没有任务时最多保持多长时间后会终止KeepAliveTime）。</li>
</ol>
<p>所以开发中多用线程池。</p>
<p><strong>创建步骤：</strong></p>
<ol>
<li>提供指定线程数量的线程池；</li>
<li>执行指定的线程的操作，此时需要提供Runnable接口或者Callbable接口实现类的对象（即确定阿要执行的线程要做些什么）；</li>
<li>关闭连接池。</li>
</ol>
<p><strong>实现代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThreadPool</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThreadPool1</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        service.submit(<span class="keyword">new</span> MyThreadPool());<span class="comment">//适合Callable</span></span><br><span class="line"><span class="comment">//        service.execute();//适合Runnable</span></span><br><span class="line">        service.submit(<span class="keyword">new</span> MyThreadPool1());</span><br><span class="line">        service.shutdown();<span class="comment">//关闭连接池</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注：</strong>ExecutorService是一个接口，service是类ThreadPoolExecutor的实例化对象，ThreadPoolExecutor继承AbstractExecutorService，AbstractExecutorService又实现了ExecutorService。要设置线程池的一些参数的化，可以先将线程池强制类型转换为ThreadPoolExecutor类，利用其中的方法来进行线程池管理设置。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>字符集</title>
    <url>/p/40261.html</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>我们在计算机屏幕上看到的是实体化的文字，而在计算机存储介质中存放的实际是二进制的比特流。那么在这两者之间的转换规则就需要一个统一的标准。简单的说字符集就规定了某个文字对应的二进制数字存放方式（编码）和某串二进制数值代表了哪个文字（解码）的转换关系。</p>
<a id="more"></a> 

<h1 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h1><ul>
<li><strong>ASCII：</strong>美国标准信息交换码，用一个字节的7位表示（128个）；</li>
<li><strong>ISO8859-1：</strong>拉丁码表。欧洲码表，用一个字节的8位表示；</li>
<li><strong>GB2312：</strong>中国的中文编码表。最多两个字节编码所有字符；</li>
<li><strong>GBK：</strong>中国的中文编码表升级，融合了更多的中文文字符号，最多两个字节编码；</li>
<li><strong>Unicode：</strong>国际标准码，融合了目前人类使用的所有字符，为每个字符分配唯一的字符码，所有的文字都使用两个字节来表示；</li>
<li><strong>UTF-8：</strong>变长的国际标准码，定义了庞大的、全球通用的字符集，为每个字符规定了唯一确定的编码，可用1-4个字节来表示一个字符。</li>
</ul>
<h1 id="字库表、编码字符集、字符编码"><a href="#字库表、编码字符集、字符编码" class="headerlink" title="字库表、编码字符集、字符编码"></a>字库表、编码字符集、字符编码</h1><p><strong>字库表（character repertoire）</strong>：相当于所有可读或者可显示字符的数据库，字库表决定了整个字符集能够展现表示的所有字符的范围。</p>
<p><strong>编码字符集（coded character set</strong>）：用一个编码值<code>code point</code>来表示一个字符在字库中的位置。</p>
<p><strong>字符编码（character encoding form）</strong>：将编码字符集和实际存储数值之间的转换关系。一般来说都会直接将code point的值作为编码后的值直接存储。例如在ASCII中<code>A</code>在表中排第65位，而编码后<code>A</code>的数值是<code>0100 0001</code>也即十进制的65的二进制转换结果。</p>
<p><code>字库表</code>和<code>编码字符集</code>看来是必不可少的，那既然字库表中的每一个字符都有一个自己的序号，直接把序号作为存储内容就好了。为什么还要多此一举通过<code>字符编码</code>把序号转换成另外一种存储格式呢？其实原因也比较容易理解：统一字库表的目的是为了能够涵盖世界上所有的字符，但实际使用过程中会发现真正用的上的字符相对整个字库表来说比例非常低。例如中文地区的程序几乎不会需要日语字符，而一些英语国家甚至简单的ASCII字库表就能满足基本需求。而如果把每个字符都用字库表中的序号来存储的话，每个字符就需要3个字节（这里以Unicode字库为例），这样对于原本用仅占一个字符的ASCII编码的英语地区国家显然是一个额外成本（存储体积是原来的三倍）。算的直接一些，同样一块硬盘，用ASCII可以存1500篇文章，而用3字节Unicode序号存储只能存500篇。于是就出现了UTF-8这样的变长编码。在UTF-8编码中原本只需要一个字节的ASCII字符，仍然只占一个字节。而像中文及日语这样的复杂字符就需要2个到3个字节来存储。</p>
<h1 id="UTF-8和Unicode的关系"><a href="#UTF-8和Unicode的关系" class="headerlink" title="UTF-8和Unicode的关系"></a>UTF-8和Unicode的关系</h1><p>Unicode就是上文中提到的编码字符集，而UTF-8就是字符编码，即Unicode规则字库的一种实现形式。随着互联网的发展，对同一字库集的要求越来越迫切，Unicode标准也就自然而然的出现。它几乎涵盖了各个国家语言可能出现的符号和文字，并将为他们编号。Unicode的编号从0000开始一直到10FFFF共分为16个Plane，每个Plane中有65536个字符。而UTF-8则只实现了第一个Plane，可见UTF-8虽然是一个当今接受度最广的字符集编码，但是它并没有涵盖整个Unicode的字库。</p>
<h2 id="UTF-8编码简介"><a href="#UTF-8编码简介" class="headerlink" title="UTF-8编码简介"></a>UTF-8编码简介</h2><ul>
<li>对于单字节的符号，字节的第一位设为0，后面7位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。</li>
<li>对于n字节的符号（n &gt; 1），第一个字节的前n位都设为1，第n + 1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。</li>
</ul>
<table>
<thead>
<tr>
<th>Unicode符号范围（十六进制）</th>
<th>UTF-8编码方式（二进制）</th>
</tr>
</thead>
<tbody><tr>
<td>0000 0000-0000 0007F</td>
<td>0xxxxxxx</td>
</tr>
<tr>
<td>0000 0080-0000 07FF</td>
<td>110xxxxx 10xxxxxx</td>
</tr>
<tr>
<td>0000 0800-0000 FFFF</td>
<td>1110xxxx 10xxxxxx 10xxxxxx</td>
</tr>
<tr>
<td>0001 0000-0010 FFFF</td>
<td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Java</category>
        <category>IO流</category>
      </categories>
      <tags>
        <tag>字符集</tag>
      </tags>
  </entry>
  <entry>
    <title>日期和时间的使用</title>
    <url>/p/48841.html</url>
    <content><![CDATA[<h1 id="System-currentTimeMillis-方法-JDK1-5"><a href="#System-currentTimeMillis-方法-JDK1-5" class="headerlink" title="System.currentTimeMillis()方法(JDK1.5)"></a>System.currentTimeMillis()方法(JDK1.5)</h1><p><strong>介绍：</strong>返回当前时间与1970年1约1日0时0分0秒之间以毫秒为单位的时间差——又称为时间戳。</p>
<p><strong>用途：</strong>比如天猫等订单，为实现唯一性，可以利用时间戳。</p>
<a id="more"></a>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> l = System.currentTimeMillis();</span><br><span class="line">System.out.println(l);</span><br></pre></td></tr></table></figure>
<h1 id="Date类：包括java-util-Date类和java-sql-Date类-JDK1-0"><a href="#Date类：包括java-util-Date类和java-sql-Date类-JDK1-0" class="headerlink" title="Date类：包括java.util.Date类和java.sql.Date类(JDK1.0)"></a>Date类：包括java.util.Date类和java.sql.Date类(JDK1.0)</h1><p><strong>介绍：</strong>java.util.Date 就是在除了SQL语句的情况下面使用；java.sql.Date 是针对SQL语句使用的，它只包含日期而没有时间部分；java.util.Date 是 java.sql.Date 的父类。</p>
<h2 id="java-util-Date类"><a href="#java-util-Date类" class="headerlink" title="java.util.Date类"></a>java.util.Date类</h2><p><strong>空构造器：</strong>创建对应当前时间的Date对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date date1 = <span class="keyword">new</span> Date();</span><br><span class="line">System.out.println(date1.toString());<span class="comment">//显示当前的年月日时分秒</span></span><br><span class="line">System.out.println(date1.getTime());<span class="comment">//获取当前对象对应的毫秒数--时间戳</span></span><br></pre></td></tr></table></figure>
<p><strong>非空构造器：</strong>创建指定时间的Date对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date date2 = <span class="keyword">new</span> Date(<span class="number">1608814866348L</span>);</span><br><span class="line">System.out.println(date2);</span><br></pre></td></tr></table></figure>
<h2 id="java-sql-Date类"><a href="#java-sql-Date类" class="headerlink" title="java.sql.Date类"></a>java.sql.Date类</h2><p><strong>构造器：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.sql.Date date3 = <span class="keyword">new</span> java.sql.Date(<span class="number">1608814866348L</span>);</span><br><span class="line">System.out.println(date3.toString());<span class="comment">//只显示年月日</span></span><br></pre></td></tr></table></figure>
<h2 id="java-util-Date和java-sql-Date之间的转换"><a href="#java-util-Date和java-sql-Date之间的转换" class="headerlink" title="java.util.Date和java.sql.Date之间的转换"></a>java.util.Date和java.sql.Date之间的转换</h2><h3 id="java-sql-Date-—-gt-java-util-Date"><a href="#java-sql-Date-—-gt-java-util-Date" class="headerlink" title="java.sql.Date —-&gt; java.util.Date"></a>java.sql.Date —-&gt; java.util.Date</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.sql.Date date = <span class="keyword">new</span> java.sql.Date();</span><br><span class="line">java.util.Date date1 = <span class="keyword">new</span> java.util.Date (date.getTime());</span><br></pre></td></tr></table></figure>
<h3 id="java-sql-Date-lt-—-java-util-Date"><a href="#java-sql-Date-lt-—-java-util-Date" class="headerlink" title="java.sql.Date &lt;—- java.util.Date"></a>java.sql.Date &lt;—- java.util.Date</h3><p>多态</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date date4 = <span class="keyword">new</span> java.sql.Date(<span class="number">1608814866348L</span>);</span><br><span class="line">java.sql.Date date5 = (java.sql.Date) date4;</span><br></pre></td></tr></table></figure>
<p>getTime()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.util.Date date6 = <span class="keyword">new</span> java.util.Date(<span class="number">1608814866348L</span>);</span><br><span class="line">java.sql.Date date7 = <span class="keyword">new</span> java.sql.Date(date6.getTime());</span><br></pre></td></tr></table></figure>
<h1 id="java-text-SimpleDateFormat类-JDK1-1"><a href="#java-text-SimpleDateFormat类-JDK1-1" class="headerlink" title="java.text.SimpleDateFormat类(JDK1.1)"></a>java.text.SimpleDateFormat类(JDK1.1)</h1><p>对日期<strong>Date类</strong>的格式化和解析。</p>
<ol>
<li><strong>格式化：</strong>日期 —&gt; 字符串</li>
<li><strong>解析：</strong>格式化的逆过程，字符串 —&gt; 日期</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeTest2</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//实例化SimpleDateFormat:使用默认的构造器</span></span><br><span class="line">        SimpleDateFormat sdf = <span class="keyword">new</span> SimpleDateFormat();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//格式化：日期 ---&gt; 字符串</span></span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        System.out.println(date);</span><br><span class="line"></span><br><span class="line">        String dateFormat = sdf.format(date);</span><br><span class="line">        System.out.println(dateFormat);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//解析：格式化的逆过程，字符串 ---&gt; 日期</span></span><br><span class="line">        String str = <span class="string">&quot;20-12-25 上午9:45&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Date dateParse = sdf.parse(str);</span><br><span class="line">            System.out.println(dateParse);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//指定格式:使用带参的构造器</span></span><br><span class="line"><span class="comment">//        SimpleDateFormat sdf1 = new SimpleDateFormat(&quot;EEE, MMM d, &#x27;&#x27;yy&quot;);</span></span><br><span class="line">        SimpleDateFormat sdf1 = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);<span class="comment">//常用</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//格式化：日期 ---&gt; 字符串</span></span><br><span class="line">        String dateFormat1 = sdf1.format(date);</span><br><span class="line">        System.out.println(dateFormat1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//解析：格式化的逆过程，字符串 ---&gt; 日期</span></span><br><span class="line">        String str1 = <span class="string">&quot;2020-12-25 09:56:14&quot;</span>;<span class="comment">//要求字符串必须是符合SimpleDateFormat识别的格式（通过构造器参数体现）</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Date parse1 = sdf1.parse(str1);</span><br><span class="line">            System.out.println(parse1);</span><br><span class="line">            <span class="keyword">boolean</span> b = parse1 <span class="keyword">instanceof</span> Date;<span class="comment">//查看parse是否是Date类对象</span></span><br><span class="line">            System.out.println(b);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ParseException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符串”1998-12-16”转换为java-sql-Date"><a href="#字符串”1998-12-16”转换为java-sql-Date" class="headerlink" title="字符串”1998-12-16”转换为java.sql.Date"></a>字符串”1998-12-16”转换为java.sql.Date</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        String birth = <span class="string">&quot;1998-12-16&quot;</span>;</span><br><span class="line">        SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">        Date birthParse = simpleDateFormat.parse(birth);</span><br><span class="line">        System.out.println(<span class="string">&quot;出生年月日：&quot;</span> + birth);</span><br><span class="line"><span class="comment">//        System.out.println(&quot;解析：&quot; + birthParse);</span></span><br><span class="line"><span class="comment">//        System.out.println(birthParse instanceof java.util.Date);</span></span><br><span class="line">        java.sql.Date birthSQL = <span class="keyword">new</span> java.sql.Date(birthParse.getTime());</span><br><span class="line"><span class="comment">//        System.out.println(birthSQL);</span></span><br><span class="line">        System.out.println(birthSQL <span class="keyword">instanceof</span> java.sql.Date);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="三天打鱼两天晒网-从1990-01-01开始-2020-12-25当天是打鱼还是晒网？"><a href="#三天打鱼两天晒网-从1990-01-01开始-2020-12-25当天是打鱼还是晒网？" class="headerlink" title="三天打鱼两天晒网 从1990-01-01开始 2020-12-25当天是打鱼还是晒网？"></a>三天打鱼两天晒网 从1990-01-01开始 2020-12-25当天是打鱼还是晒网？</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> <span class="keyword">throws</span> ParseException </span>&#123;</span><br><span class="line">        String startDay = <span class="string">&quot;1990-01-01&quot;</span>;</span><br><span class="line">        String endDay = <span class="string">&quot;2020-12-22&quot;</span>;</span><br><span class="line">        SimpleDateFormat simpleDateFormat = <span class="keyword">new</span> SimpleDateFormat(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line">        java.util.Date startDayDate = simpleDateFormat.parse(startDay);</span><br><span class="line">        java.util.Date endDayDate = simpleDateFormat.parse(endDay);</span><br><span class="line">        <span class="keyword">long</span> howManyDays = (endDayDate.getTime() - startDayDate.getTime()) / (<span class="number">24</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">long</span> remainder = howManyDays % <span class="number">5</span>;</span><br><span class="line">        System.out.println(remainder);</span><br><span class="line">        <span class="keyword">if</span> (remainder==<span class="number">1</span> || remainder==<span class="number">2</span> || remainder==<span class="number">3</span>)&#123;</span><br><span class="line">            System.out.println(endDay + <span class="string">&quot;在打鱼。&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(endDay + <span class="string">&quot;在晒网。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="Calendar日历类-可变的-JDK1-1"><a href="#Calendar日历类-可变的-JDK1-1" class="headerlink" title="Calendar日历类(可变的, JDK1.1)"></a>Calendar日历类(可变的, JDK1.1)</h1><p><strong>实例化：</strong></p>
<ol>
<li>创建其子类GregorianCalendar的对象；</li>
<li>调用其静态方法getInstance()。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Calendar calendar = Calendar.getInstance();</span><br></pre></td></tr></table></figure>
<p><strong>常用方法：</strong></p>
<ul>
<li>get()</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> months = calendar.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">System.out.println(months);<span class="comment">//25</span></span><br><span class="line"><span class="keyword">int</span> years = calendar.get(Calendar.DAY_OF_YEAR);</span><br><span class="line">System.out.println(years);<span class="comment">//360</span></span><br></pre></td></tr></table></figure>
<ul>
<li>set()</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">calendar.set(Calendar.DAY_OF_YEAR, <span class="number">45</span>);</span><br><span class="line">System.out.println(calendar.get(Calendar.DAY_OF_YEAR));<span class="comment">//45</span></span><br></pre></td></tr></table></figure>
<ul>
<li>add()</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">calendar.add(Calendar.DAY_OF_YEAR, <span class="number">2</span>);</span><br><span class="line">System.out.println(calendar.get(Calendar.DAY_OF_YEAR));<span class="comment">//47</span></span><br></pre></td></tr></table></figure>
<ul>
<li>getTime()</li>
</ul>
<p>日历类 —&gt; Date类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date time = calendar.getTime();</span><br><span class="line">System.out.println(time);<span class="comment">//Date类的一个对象（修改之后的）Sun Feb 16 11:54:29 CST 2020</span></span><br></pre></td></tr></table></figure>
<ul>
<li>setTime()</li>
</ul>
<p>Date类 —&gt; 日历类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date date = <span class="keyword">new</span> Date();</span><br><span class="line">calendar.setTime(date);</span><br><span class="line">System.out.println(calendar.get(Calendar.DAY_OF_MONTH));<span class="comment">//25</span></span><br></pre></td></tr></table></figure>
<h1 id="Java-8中新日期时间API"><a href="#Java-8中新日期时间API" class="headerlink" title="Java 8中新日期时间API"></a>Java 8中新日期时间API</h1><h2 id="java-util-Date和Calendar类面临的问题："><a href="#java-util-Date和Calendar类面临的问题：" class="headerlink" title="java.util.Date和Calendar类面临的问题："></a>java.util.Date和Calendar类面临的问题：</h2><ul>
<li><strong>可变性：</strong>日期和时间可以直接修改；</li>
<li><strong>偏移性：</strong>Date类的年份是从1900年开始的，月份是从0开始的；Calendar类月份也是从0开始。这意味着如果我们要表示2020年8月16日，那么我们需要创建以下的Date实例：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date date = <span class="keyword">new</span> Date(<span class="number">2020</span>-<span class="number">1900</span>, <span class="number">8</span>-<span class="number">1</span>, <span class="number">16</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>格式化：</strong>格式化只对Date有用，Calendar则不行；</li>
<li><strong>非线程安全的</strong></li>
</ul>
<h2 id="LocalDate、LocalTime、LocalDateTime"><a href="#LocalDate、LocalTime、LocalDateTime" class="headerlink" title="LocalDate、LocalTime、LocalDateTime"></a>LocalDate、LocalTime、LocalDateTime</h2><ul>
<li><strong>now()：</strong>获取当前的日期、时间、日期和时间</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDate localDate = LocalDate.now();</span><br><span class="line">LocalTime localTime = LocalTime.now();</span><br><span class="line">LocalDateTime localDateTime = LocalDateTime.now();</span><br><span class="line">System.out.println(localDate);</span><br><span class="line">System.out.println(localTime);</span><br><span class="line">System.out.println(localDateTime);</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>of()：</strong>设置指定时间（年月日时分秒），没有偏移量</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDateTime localDateTime1 = LocalDateTime.of(<span class="number">1998</span>,<span class="number">8</span>,<span class="number">16</span>,<span class="number">13</span>,<span class="number">24</span>, <span class="number">4</span>);</span><br><span class="line">System.out.println(localDateTime1);<span class="comment">//1998-08-16T13:24:04</span></span><br></pre></td></tr></table></figure>
<ul>
<li>**getXxx():**获取月份字段、星期几字段、日期字段、使用 <code>Month</code>枚举获取月份字段、将月份字段从1到12。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(localDateTime1.getDayOfMonth());<span class="comment">//16</span></span><br><span class="line">System.out.println(localDateTime1.getDayOfWeek());<span class="comment">//SUNDAY</span></span><br><span class="line">System.out.println(localDateTime1.getDayOfYear());<span class="comment">//228</span></span><br><span class="line">System.out.println(localDateTime1.getMonth());<span class="comment">//AUGUST</span></span><br><span class="line">System.out.println(localDateTime1.getMonthValue());<span class="comment">//8</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>withXxx():**返回此日期的副本，并更改日期(体现了</strong>不可变性**)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDateTime localDateTime2 = localDateTime1.withDayOfMonth(<span class="number">9</span>);</span><br><span class="line">System.out.println(localDateTime1);<span class="comment">//1998-08-16T13:24:04</span></span><br><span class="line">System.out.println(localDateTime2);<span class="comment">//1998-08-09T13:24:04</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>plusXxx():**加上几天并返回副本</strong>(不可变性**)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDateTime localDateTime3 = localDateTime1.plusDays(<span class="number">10</span>);</span><br><span class="line">System.out.println(localDateTime1);<span class="comment">//1998-08-16T13:24:04</span></span><br><span class="line">System.out.println(localDateTime3);<span class="comment">//1998-08-26T13:24:04</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>minusXxx():**减去几天并返回副本</strong>(不可变性)**</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LocalDateTime localDateTime4 = localDateTime1.minusDays(<span class="number">10</span>);</span><br><span class="line">System.out.println(localDateTime1);<span class="comment">//1998-08-16T13:24:04</span></span><br><span class="line">System.out.println(localDateTime4);<span class="comment">//1998-08-06T13:24:04</span></span><br></pre></td></tr></table></figure>
<h2 id="瞬时：Instant"><a href="#瞬时：Instant" class="headerlink" title="瞬时：Instant"></a>瞬时：Instant</h2><p><code>java.time.Instant</code>类对时间建模的方式，基本上它是以Unix元年时间(传统的设定为UTC时区1970年1月1日午夜时分)开始所经历的毫秒数进行计算（时间戳）。提供机器视图。</p>
<ul>
<li><strong>now()</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Instant instant = Instant.now();<span class="comment">//从系统时钟获取当前瞬间(本初子午线的时间)。</span></span><br><span class="line">System.out.println(instant);<span class="comment">//2020-12-25T08:31:23.854Z</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">OffsetDateTime offsetDateTime = instant.atOffset(ZoneOffset.ofHours(<span class="number">8</span>));<span class="comment">//将此瞬间与偏移组合起来创建一个 OffsetDateTime 。</span></span><br><span class="line">System.out.println(offsetDateTime);<span class="comment">//2020-12-25T16:31:23.854+08:00</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>toEpochMilli()</strong>:获取对应时间与1970年1月1日0时0分0秒相差的毫秒数</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> l = instant.toEpochMilli();</span><br><span class="line">System.out.println(l);<span class="comment">//1608885344151</span></span><br></pre></td></tr></table></figure>
<ul>
<li>**ofEpochMilli():**通过给定的毫秒数，获取Instant实例，类似于Date类中的getTime()方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Instant instant1 = Instant.ofEpochMilli(<span class="number">1608885344151L</span>);</span><br><span class="line">System.out.println(instant1);<span class="comment">//2020-12-25T08:35:44.151Z</span></span><br></pre></td></tr></table></figure>
<h2 id="java-time-format-DateTimeFormatter类"><a href="#java-time-format-DateTimeFormatter类" class="headerlink" title="java.time.format.DateTimeFormatter类"></a>java.time.format.DateTimeFormatter类</h2><p>类似于SimpleDateFormat类，提供了三种格式化方法：</p>
<h3 id="方式一：预定义的标准格式"><a href="#方式一：预定义的标准格式" class="headerlink" title="方式一：预定义的标准格式"></a>方式一：预定义的标准格式</h3><p>如ISO_LOCAL_DATE、ISO_LOCAL_TIME、ISO_LOCAL_DATETIME等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DateTimeFormatter formatter = DateTimeFormatter.ISO_LOCAL_DATE_TIME;</span><br><span class="line">LocalDateTime now = LocalDateTime.now();</span><br><span class="line"><span class="comment">//格式化</span></span><br><span class="line">String formatNow = formatter.format(now);</span><br><span class="line">System.out.println(now);</span><br><span class="line">System.out.println(formatNow);</span><br><span class="line"><span class="comment">//解析</span></span><br><span class="line">TemporalAccessor parseNow = formatter.parse(formatNow);</span><br><span class="line">System.out.println(parseNow);</span><br></pre></td></tr></table></figure>
<h3 id="方式二：使用模式字母"><a href="#方式二：使用模式字母" class="headerlink" title="方式二：使用模式字母"></a>方式二：使用模式字母</h3><p>如：ofLocalizedDateTime()、ofLocalizedDate()</p>
<p>参数：FormatStyle.LONG / FormatStyle.MEDIUM / FormatStyle.SHORT</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DateTimeFormatter formatter = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.LONG  );</span><br><span class="line">LocalDateTime now = LocalDateTime.now();</span><br><span class="line"><span class="comment">//格式化</span></span><br><span class="line">String formatNow = formatter.format(now);</span><br><span class="line">System.out.println(now);</span><br><span class="line">System.out.println(formatNow);</span><br><span class="line"><span class="comment">//解析</span></span><br><span class="line">TemporalAccessor parseNow = formatter.parse(formatNow);</span><br><span class="line">System.out.println(parseNow);</span><br></pre></td></tr></table></figure>
<p><strong>results:</strong></p>
<p><strong>FormatStyle.LONG</strong>:2020年12月28日 下午04时02分04秒</p>
<p>**FormatStyle.MEDIUM:**2020-12-28 16:03:02</p>
<p>**FormatStyle.SHORT:**20-12-28 下午4:03</p>
<h3 id="方式三：使用本地化样式"><a href="#方式三：使用本地化样式" class="headerlink" title="方式三：使用本地化样式"></a>方式三：使用本地化样式</h3><p>如:<strong>DateTimeFormatter.ofPattern()</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy MM dd&quot;</span>);</span><br><span class="line">LocalDateTime now = LocalDateTime.now();</span><br><span class="line"><span class="comment">//格式化</span></span><br><span class="line">String formatNow = formatter.format(now);</span><br><span class="line">System.out.println(now);</span><br><span class="line">System.out.println(formatNow);<span class="comment">//2020 12 28</span></span><br><span class="line"><span class="comment">//解析</span></span><br><span class="line">TemporalAccessor parseNow = formatter.parse(formatNow);</span><br><span class="line">System.out.println(parseNow);</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
        <category>日期和时间</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>日期</tag>
        <tag>时间</tag>
      </tags>
  </entry>
  <entry>
    <title>死锁</title>
    <url>/p/28384.html</url>
    <content><![CDATA[<h1 id="死锁的定义"><a href="#死锁的定义" class="headerlink" title="死锁的定义"></a><strong>死锁的定义</strong></h1><p>多线程以及多进程改善了系统资源的利用率并提高了系统 的处理能力。然而，并发执行也带来了新的问题——死锁。所谓死锁是指多个线程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进。</p>
<a id="more"></a>

<h1 id="死锁产生的原因"><a href="#死锁产生的原因" class="headerlink" title="死锁产生的原因"></a><strong>死锁产生的原因</strong></h1><p><strong>1.系统资源的竞争</strong></p>
<p>通常系统中拥有的不可剥夺资源，其数量不足以满足多个进程运行的需要，使得进程在运行过程中，会因争夺资源而陷入僵局，如磁带机、打印机等。只有对不可剥夺资源的竞争才可能产生死锁，对可剥夺资源的竞争是不会引起死锁的。</p>
<p><strong>2.进程推进顺序非法</strong></p>
<p>Java中死锁最简单的情况是，一个线程T1持有锁L1并且申请获得锁L2，而另一个线程T2持有锁L2并且申请获得锁L1，因为默认的锁申请操作都是阻塞的，所以线程T1和T2永远被阻塞了。导致了死锁。</p>
<p>总而言之，产生死锁可能性的最根本原因是：<strong>线程在获得一个锁L1的情况下再去申请另外一个锁L2，也就是锁L1想要包含了锁L2，也就是说在获得了锁L1，并且没有释放锁L1的情况下，又去申请获得锁L2，这个是产生死锁的最根本原因</strong>。另一个原因是<strong>默认的锁申请操作是阻塞的</strong>。</p>
<h1 id="死锁产生的必要条件"><a href="#死锁产生的必要条件" class="headerlink" title="死锁产生的必要条件"></a><strong>死锁产生的必要条件</strong></h1><p><strong>1.互斥条件</strong>：一个资源每次只能被一个线程使用。此时若有其他进程请求该资源，则请求进程只能等待。</p>
<p><strong>2.不剥夺条件：</strong>进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)。</p>
<p><strong>3.请求和保持条件</strong>：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。</p>
<p><strong>4.循环等待条件：</strong>若干进程之间形成一种头尾相接的循环等待资源关系。</p>
<p>注：循环等待条件和死锁的区别</p>
<p>循环等待条件是存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被链中下一个进程所请求。即存在一个处于等待状态的进程集合{Pl, P2, …, pn}，其中Pi等 待的资源被P(i+1)占有（i=0, 1, …, n-1)，Pn等待的资源被P0占有。</p>
<p>直观上看，循环等待条件似乎和死锁的定义一样，其实不然。按死锁定义构成等待环所 要求的条件更严，它要求Pi等待的资源必须由P(i+1)来满足，而循环等待条件则无此限制。 例如，系统中有两台输出设备，P0占有一台，PK占有另一台，且K不属于集合{0, 1, …, n}。</p>
<p> Pn等待一台输出设备，它可以从P0获得，也可能从PK获得。因此，虽然Pn、P0和其他 一些进程形成了循环等待圈，但PK不在圈内，若PK释放了输出设备，则可打破循环等待。因此循环等待只是死锁的必要条件。</p>
<p>总的来说，<strong>死锁要求当前进程只能从循环链的下一个来满足，而循环等待条件是可以从循环链下一个来获取，也可以从其他途径获得。</strong></p>
<h1 id="死锁的实例"><a href="#死锁的实例" class="headerlink" title="死锁的实例"></a>死锁的实例</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Object lock1 = <span class="keyword">new</span> Object();</span><br><span class="line">        Object lock2 = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; got lock1, want lock2&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; got lock2&quot;</span>);</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; got lock1 and lock2&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock2) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; got lock2, want lock1&quot;</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">synchronized</span> (lock1) &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; got lock1&quot;</span>);</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; got lock2 and lock1&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Thread-0 got lock1, want lock2</span><br><span class="line">Thread-1 got lock2, want lock1</span><br></pre></td></tr></table></figure>
<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<h1 id="如何避免死锁"><a href="#如何避免死锁" class="headerlink" title="如何避免死锁"></a><strong>如何避免死锁</strong></h1><p>死锁是由四个必要条件导致的，所以一般来说，只要破坏这四个必要条件中的一个条件，死锁情况就应该不会发生。</p>
<ul>
<li>加锁顺序（线程按照一定的顺序加锁）</li>
<li>加锁时限（线程尝试获取锁的时候加上一定的时限，超过时限则放弃对该锁的请求，并释放自己占有的锁）</li>
<li>死锁检测</li>
</ul>
<h2 id="1-加锁顺序"><a href="#1-加锁顺序" class="headerlink" title="1.加锁顺序"></a>1.加锁顺序</h2><p>当多个线程需要相同的一些锁，但是按照不同的顺序加锁，死锁就很容易发生。如果能确保所有的线程都是按照相同的顺序获得锁，那么死锁就不会发生。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Thread 1:</span><br><span class="line">  lock A </span><br><span class="line">  lock B</span><br><span class="line"></span><br><span class="line">Thread 2:</span><br><span class="line">   wait for A</span><br><span class="line">   lock C (when A locked)</span><br><span class="line"></span><br><span class="line">Thread 3:</span><br><span class="line">   wait for A</span><br><span class="line">   wait for B</span><br><span class="line">   wait for C</span><br></pre></td></tr></table></figure>
<p>如果一个线程（比如线程3）需要一些锁，那么它必须按照确定的顺序获取锁。它只有获得了从顺序上排在前面的锁之后，才能获取后面的锁。</p>
<p>例如，线程2和线程3只有在获取了锁A之后才能尝试获取锁C(<em>获取锁A是获取锁C的必要条件</em>)。因为线程1已经拥有了锁A，所以线程2和3需要一直等到锁A被释放。然后在它们尝试对B或C加锁之前，必须成功地对A加了锁。</p>
<p>按照顺序加锁是一种有效的死锁预防机制。但是，这种方式需要你事先知道所有可能会用到的锁(<em>并对这些锁做适当的排序</em>)，但总有些时候是无法预知的。</p>
<h2 id="2-加锁时限"><a href="#2-加锁时限" class="headerlink" title="2.加锁时限"></a>2.加锁时限</h2><p>另外一个可以避免死锁的方法是在尝试获取锁的时候加一个超时时间，这也就意味着在尝试获取锁的过程中若超过了这个时限该线程则放弃对该锁请求。若一个线程没有在给定的时限内成功获得所有需要的锁，则会进行回退并释放所有已经获得的锁，然后等待一段随机的时间再重试。这段随机的等待时间让其它线程有机会尝试获取相同的这些锁，并且让该应用在没有获得锁的时候可以继续运行(<em>加锁超时后可以先继续运行干点其它事情，再回头来重复之前加锁的逻辑</em>)。</p>
<p>这种机制存在一个问题，在Java中不能对synchronized同步块设置超时时间。你需要创建一个自定义锁，或使用Java5中java.util.concurrent包下的工具。</p>
<h2 id="3-死锁检测"><a href="#3-死锁检测" class="headerlink" title="3.死锁检测"></a><strong>3.死锁检测</strong></h2><p>死锁检测是一个更好的死锁预防机制，它主要是针对那些不可能实现按序加锁并且锁超时也不可行的场景。</p>
<p>每当一个线程获得了锁，会在线程和锁相关的数据结构中（map、graph等等）将其记下。除此之外，每当有线程请求锁，也需要记录在这个数据结构中。当一个线程请求锁失败时，这个线程可以遍历锁的关系图看看是否有死锁发生。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>枚举类</title>
    <url>/p/20039.html</url>
    <content><![CDATA[<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><ul>
<li>类的对象只有有限个，确定的</li>
<li>需要定义一组常量时，使用枚举类</li>
<li>枚举类中只有一个对象，可以当作单例模式的一种实现方式</li>
</ul>
<a id="more"></a>

<h1 id="定义枚举类"><a href="#定义枚举类" class="headerlink" title="定义枚举类"></a>定义枚举类</h1><h2 id="方式一：自定义枚举类-jdk5-0之前"><a href="#方式一：自定义枚举类-jdk5-0之前" class="headerlink" title="方式一：自定义枚举类 jdk5.0之前"></a>方式一：自定义枚举类 jdk5.0之前</h2><ul>
<li>声明Week对象的属性：private final修饰（因为枚举类内的对象是常量）</li>
<li>私有化类的构造器，并给对象的属性赋值</li>
<li>提供当前枚举类的多个对象：public static final修饰（外部能调用但是不能修改）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Week friday = Week.FRIDAY;</span><br><span class="line">        System.out.println(friday.toString());<span class="comment">//Week&#123;weekName=&#x27;Monday&#x27;, weekDesc=&#x27;星期五&#x27;&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Week</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String weekName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String weekDesc;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Week</span><span class="params">(String weekName, String weekDesc)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.weekName = weekName;</span><br><span class="line">        <span class="keyword">this</span>.weekDesc = weekDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getWeekName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> weekName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getWeekDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> weekDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Week&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;weekName=&#x27;&quot;</span> + weekName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, weekDesc=&#x27;&quot;</span> + weekDesc + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Week MONDAY = <span class="keyword">new</span> Week(<span class="string">&quot;Monday&quot;</span>,<span class="string">&quot;星期一&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Week TUESDAY = <span class="keyword">new</span> Week(<span class="string">&quot;Monday&quot;</span>,<span class="string">&quot;星期二&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Week WEDNESDAY = <span class="keyword">new</span> Week(<span class="string">&quot;Monday&quot;</span>,<span class="string">&quot;星期三&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Week THURSDAY = <span class="keyword">new</span> Week(<span class="string">&quot;Monday&quot;</span>,<span class="string">&quot;星期四&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Week FRIDAY = <span class="keyword">new</span> Week(<span class="string">&quot;Monday&quot;</span>,<span class="string">&quot;星期五&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Week SATURDAY = <span class="keyword">new</span> Week(<span class="string">&quot;Monday&quot;</span>,<span class="string">&quot;星期六&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Week SUNDAY = <span class="keyword">new</span> Week(<span class="string">&quot;Monday&quot;</span>,<span class="string">&quot;星期日&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方式二：使用enum关键字定义枚举类-jdk5-0"><a href="#方式二：使用enum关键字定义枚举类-jdk5-0" class="headerlink" title="方式二：使用enum关键字定义枚举类 jdk5.0"></a>方式二：使用enum关键字定义枚举类 jdk5.0</h2><ul>
<li>提供当前枚举类的对象，多个对象之间使用逗号隔开，最后一个对象使用分号结束</li>
<li>不用提供toString方法，默认打印出来的是此枚举常量的名称（enum 类的父类不是Object类，是Enum类）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Week1 monday = Week1.MONDAY;</span><br><span class="line">        System.out.println(monday.toString());<span class="comment">//MONDAY</span></span><br><span class="line">        System.out.println(Week1.class.getSuperclass());<span class="comment">//class java.lang.Enum</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Week1</span></span>&#123;</span><br><span class="line">    MONDAY(<span class="string">&quot;Monday&quot;</span>,<span class="string">&quot;星期一&quot;</span>),</span><br><span class="line">    TUESDAY(<span class="string">&quot;Monday&quot;</span>,<span class="string">&quot;星期二&quot;</span>),</span><br><span class="line">    WEDNESDAY(<span class="string">&quot;Monday&quot;</span>,<span class="string">&quot;星期三&quot;</span>),</span><br><span class="line">    THURSDAY(<span class="string">&quot;Monday&quot;</span>,<span class="string">&quot;星期四&quot;</span>),</span><br><span class="line">    FRIDAY(<span class="string">&quot;Monday&quot;</span>,<span class="string">&quot;星期五&quot;</span>),</span><br><span class="line">    SATURDAYWeek(<span class="string">&quot;Monday&quot;</span>,<span class="string">&quot;星期六&quot;</span>),</span><br><span class="line">    SUNDAY(<span class="string">&quot;Monday&quot;</span>,<span class="string">&quot;星期日&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String weekName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String weekDesc;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Week1</span><span class="params">(String weekName, String weekDesc)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.weekName = weekName;</span><br><span class="line">        <span class="keyword">this</span>.weekDesc = weekDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getWeekName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> weekName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getWeekDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> weekDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    @Override</span></span><br><span class="line"><span class="comment">//    public String toString() &#123;</span></span><br><span class="line"><span class="comment">//        return &quot;Week&#123;&quot; +</span></span><br><span class="line"><span class="comment">//                &quot;weekName=&#x27;&quot; + weekName + &#x27;\&#x27;&#x27; +</span></span><br><span class="line"><span class="comment">//                &quot;, weekDesc=&#x27;&quot; + weekDesc + &#x27;\&#x27;&#x27; +</span></span><br><span class="line"><span class="comment">//                &#x27;&#125;&#x27;;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="使用enum关键字定义的枚举类实现接口"><a href="#使用enum关键字定义的枚举类实现接口" class="headerlink" title="使用enum关键字定义的枚举类实现接口"></a>使用enum关键字定义的枚举类实现接口</h1><p><strong>情况一：和普通类实现接口的方法一样</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Week1 monday = Week1.MONDAY;</span><br><span class="line">        System.out.println(monday.toString());</span><br><span class="line">        Week1 tuesday = Week1.TUESDAY;</span><br><span class="line">        System.out.println(tuesday.toString());</span><br><span class="line">        monday.show();<span class="comment">//今天是周一</span></span><br><span class="line">        tuesday.show();<span class="comment">//今天是周二</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Day</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Week1</span> <span class="keyword">implements</span> <span class="title">Day</span></span>&#123;</span><br><span class="line">    MONDAY(<span class="string">&quot;Monday&quot;</span>,<span class="string">&quot;星期一&quot;</span>),</span><br><span class="line">    TUESDAY(<span class="string">&quot;Monday&quot;</span>,<span class="string">&quot;星期二&quot;</span>),</span><br><span class="line">    WEDNESDAY(<span class="string">&quot;Monday&quot;</span>,<span class="string">&quot;星期三&quot;</span>),</span><br><span class="line">    THURSDAY(<span class="string">&quot;Monday&quot;</span>,<span class="string">&quot;星期四&quot;</span>),</span><br><span class="line">    FRIDAY(<span class="string">&quot;Monday&quot;</span>,<span class="string">&quot;星期五&quot;</span>),</span><br><span class="line">    SATURDAYWeek(<span class="string">&quot;Monday&quot;</span>,<span class="string">&quot;星期六&quot;</span>),</span><br><span class="line">    SUNDAY(<span class="string">&quot;Monday&quot;</span>,<span class="string">&quot;星期日&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String weekName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String weekDesc;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Week1</span><span class="params">(String weekName, String weekDesc)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.weekName = weekName;</span><br><span class="line">        <span class="keyword">this</span>.weekDesc = weekDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getWeekName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> weekName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getWeekDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> weekDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是一周内的一天&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时每一个Enum对象调用show()方法都调用的同一个。</p>
<p><strong>情况二：在每一个Enum对象中都重写接口中的抽象方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Week1 monday = Week1.MONDAY;</span><br><span class="line">        System.out.println(monday.toString());</span><br><span class="line">        Week1 tuesday = Week1.TUESDAY;</span><br><span class="line">        System.out.println(tuesday.toString());</span><br><span class="line">        monday.show();</span><br><span class="line">        tuesday.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Day</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Week1</span> <span class="keyword">implements</span> <span class="title">Day</span></span>&#123;</span><br><span class="line">    MONDAY(<span class="string">&quot;Monday&quot;</span>,<span class="string">&quot;星期一&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;今天是周一&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    TUESDAY(<span class="string">&quot;Monday&quot;</span>,<span class="string">&quot;星期二&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;今天是周二&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    WEDNESDAY(<span class="string">&quot;Monday&quot;</span>,<span class="string">&quot;星期三&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;今天是周三&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    THURSDAY(<span class="string">&quot;Monday&quot;</span>,<span class="string">&quot;星期四&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;今天是周四&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    FRIDAY(<span class="string">&quot;Monday&quot;</span>,<span class="string">&quot;星期五&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;今天是周五&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    SATURDAY(<span class="string">&quot;Monday&quot;</span>,<span class="string">&quot;星期六&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;周六来了&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    SUNDAY(<span class="string">&quot;Monday&quot;</span>,<span class="string">&quot;星期日&quot;</span>) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;周日周日&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String weekName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String weekDesc;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Week1</span><span class="params">(String weekName, String weekDesc)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.weekName = weekName;</span><br><span class="line">        <span class="keyword">this</span>.weekDesc = weekDesc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getWeekName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> weekName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getWeekDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> weekDesc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时每一个Enum对象调用show()方法都是自己定义的。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
        <category>枚举类</category>
      </categories>
      <tags>
        <tag>枚举类</tag>
      </tags>
  </entry>
  <entry>
    <title>泛型</title>
    <url>/p/2053.html</url>
    <content><![CDATA[<h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><a id="more"></a>

<p><a href="https://www.cnblogs.com/coprince/p/8603492.html">参考该文章</a></p>
<p>泛型，即“<strong>参数化类型</strong>”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是<strong>将类型由原来的具体的类型参数化</strong>，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。</p>
<p>泛型的本质是为了<strong>参数化类型</strong>（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，<strong>操作的数据类型被指定为一个参数</strong>，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。</p>
<h1 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List arrayList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">arrayList.add(<span class="string">&quot;aaaa&quot;</span>);</span><br><span class="line">arrayList.add(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; arrayList.size();i++)&#123;</span><br><span class="line">    String item = (String)arrayList.get(i);</span><br><span class="line">    Log.d(<span class="string">&quot;泛型测试&quot;</span>,<span class="string">&quot;item = &quot;</span> + item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>执行结果：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String</span><br></pre></td></tr></table></figure>
<p>ArrayList可以存放任意类型，例子中添加了一个String类型，添加了一个Integer类型，再使用时都以String的方式使用，因此程序崩溃了。为了解决类似这样的问题（在编译阶段就可以解决），泛型应运而生。</p>
<p><strong>修改：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br></pre></td></tr></table></figure>
<p>我们将第一行声明初始化list的代码更改一下，编译器会在编译阶段就能够帮我们发现类似这样的问题。</p>
<h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><p><strong>泛型只在编译阶段有效</strong>。看下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; stringArrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">List&lt;Integer&gt; integerArrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">Class classStringArrayList = stringArrayList.getClass();</span><br><span class="line">Class classIntegerArrayList = integerArrayList.getClass();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(classStringArrayList.equals(classIntegerArrayList))&#123;</span><br><span class="line">    Log.d(<span class="string">&quot;泛型测试&quot;</span>,<span class="string">&quot;类型相同&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：D/泛型测试: 类型相同。</p>
<p>通过上面的例子可以证明，<strong>在编译之后程序会采取去泛型化的措施</strong>。也就是说Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。</p>
<p>对此总结成一句话：泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型。</p>
<h1 id="泛型的使用"><a href="#泛型的使用" class="headerlink" title="泛型的使用"></a>泛型的使用</h1><p>泛型有三种使用方式，分别为：泛型类、泛型接口、泛型方法。</p>
<h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><p>举例如下：</p>
<p><strong>泛型类Order：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    String orderName;</span><br><span class="line">    <span class="keyword">int</span> orderId;</span><br><span class="line"></span><br><span class="line">    T oderT;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Order</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Order</span><span class="params">(String orderName, <span class="keyword">int</span> orderId, T oderT)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.orderName = orderName;</span><br><span class="line">        <span class="keyword">this</span>.orderId = orderId;</span><br><span class="line">        <span class="keyword">this</span>.oderT = oderT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getOrderName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> orderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOrderName</span><span class="params">(String orderName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.orderName = orderName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrderId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> orderId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOrderId</span><span class="params">(<span class="keyword">int</span> orderId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.orderId = orderId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getOderT</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> oderT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOderT</span><span class="params">(T oderT)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.oderT = oderT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Order&lt;Integer&gt; order = <span class="keyword">new</span> Order&lt;Integer&gt;(<span class="string">&quot;jyd&quot;</span>,<span class="number">1001</span>,<span class="number">25</span>);</span><br><span class="line">order.setOderT(<span class="number">23</span>);</span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong></p>
<ul>
<li>泛型类可能有多个参数，此时应该将多个参数一起放在进括号里，比如：&lt;T1,T2,T3&gt;；</li>
<li>在使用泛型的时候如果传入泛型实参，则会根据传入的泛型实参做相应的限制，此时泛型才会起到本应起到的限制作用。如果不传入泛型类型实参的话，默认Object类，但是不等于Object；</li>
<li>泛型的类型参数只能是类，不能是基本数据类型int等，要使用其包装类；</li>
<li>一个泛型类，其子类可以确定泛型的类型参数，也可以选择不确定，继续使用父类的符号<T>（…）来表示；</T></li>
</ul>
<p><img src="/p/Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210109221654067.png" alt="image-20210109221654067"></p>
<ul>
<li>不能对确切的泛型类型使用instanceof操作。如下面的操作是非法的，编译时会出错；</li>
<li>静态方法中不能使用类的泛型。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(ex_num <span class="keyword">instanceof</span> Order&lt;T&gt;)&#123; &#125;</span><br></pre></td></tr></table></figure>
<h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>泛型接口与泛型类的定义及使用基本相同。泛型接口常被用在各种类的生产器中，可以看一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个泛型接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当实现泛型接口的类，未传入泛型实参时：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中</span></span><br><span class="line"><span class="comment"> * 即：class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&#123;</span></span><br><span class="line"><span class="comment"> * 如果不声明泛型，如：class FruitGenerator implements Generator&lt;T&gt;，编译器会报错：&quot;Unknown class&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FruitGenerator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当实现泛型接口的类，传入泛型实参时：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 传入泛型实参时：</span></span><br><span class="line"><span class="comment"> * 定义一个生产器实现这个接口,虽然我们只创建了一个泛型接口Generator&lt;T&gt;</span></span><br><span class="line"><span class="comment"> * 但是我们可以为T传入无数个实参，形成无数种类型的Generator接口。</span></span><br><span class="line"><span class="comment"> * 在实现类实现泛型接口时，如已将泛型类型传入实参类型，则所有使用泛型的地方都要替换成传入的实参类型</span></span><br><span class="line"><span class="comment"> * 即：Generator&lt;T&gt;，public T next();中的的T都要替换成传入的String类型。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitGenerator</span> <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String[] fruits = <span class="keyword">new</span> String[]&#123;<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Pear&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Random rand = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">return</span> fruits[rand.nextInt(<span class="number">3</span>)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><ul>
<li>在方法中出现了泛型结构，泛型参数与类的泛型参数没有关系。即泛型方法所属的类是不是泛型类都没有关系。</li>
<li>泛型方法可以声明为静态的，主要原因是泛型参数是在调用方法时确定的，并非是在实例化类时确定的。</li>
</ul>
<p>举例：</p>
<p>Order类中的泛型方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">copyArrayToList</span><span class="params">(E[] arr)</span></span>&#123;</span><br><span class="line">    ArrayList&lt;E&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (E e : arr)&#123;</span><br><span class="line">        list.add(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">//测试泛型方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Order&lt;String&gt; order = <span class="keyword">new</span> Order&lt;String&gt;();</span><br><span class="line">    Integer[] arr = <span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">    List&lt;Integer&gt; list = order.copyArrayToList(arr);</span><br><span class="line">    System.out.println(list);<span class="comment">//[1, 2, 3, 4]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="泛型在继承方面的体现"><a href="#泛型在继承方面的体现" class="headerlink" title="泛型在继承方面的体现"></a>泛型在继承方面的体现</h2><ul>
<li>类A是类B的父类，G<A>和G<B>不具备子父类关系，是并列关系；</B></A></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;Object&gt; list1 &#x3D; null;</span><br><span class="line">List&lt;Object&gt; list2 &#x3D; null;</span><br><span class="line">list1 &#x3D; list2;&#x2F;&#x2F;编译不通过</span><br></pre></td></tr></table></figure>
<ul>
<li>类A是类B的父类（或实现关系），A<G>是B<G>的父类（或实现关系）</G></G></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list1 &#x3D; null;</span><br><span class="line">ArrayList&lt;String&gt; list2 &#x3D; null;</span><br><span class="line">list1 &#x3D; list2;&#x2F;&#x2F;没有问题</span><br></pre></td></tr></table></figure>
<h2 id="通配符-的使用"><a href="#通配符-的使用" class="headerlink" title="通配符 ? 的使用"></a>通配符 ? 的使用</h2><ul>
<li>类A是类B的父类，G<A>和G<B>不具备子父类关系，他们共同的父类是<strong>G&lt;?&gt;</strong></B></A></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Object&gt; list1 = <span class="keyword">null</span>;</span><br><span class="line">List&lt;String&gt; list2 = <span class="keyword">null</span>;</span><br><span class="line">List&lt;?&gt; list = <span class="keyword">null</span>;</span><br><span class="line">list = list1;<span class="comment">//没问题</span></span><br><span class="line">list = list2;<span class="comment">//没问题</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(List&lt;?&gt; list)</span></span>&#123;</span><br><span class="line">    Iterator&lt;?&gt; iterator = list.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">        Object o = iterator.next();</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>添加（写入）：对于List&lt;?&gt;不能向其内部类添加数据</li>
<li>获取（读取）：允许读取数据，读取的数据类型为Object</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list3 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list3.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">list3.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">list3.add(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">list = list3;</span><br><span class="line">list.add(<span class="string">&quot;d&quot;</span>);<span class="comment">//错误的</span></span><br><span class="line">list.add(<span class="keyword">null</span>);<span class="comment">//只可以加null</span></span><br><span class="line"></span><br><span class="line">Object o = list.get(<span class="number">0</span>);</span><br><span class="line">System.out.println(o);<span class="comment">//a</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>有限制的通配符</strong><ul>
<li>通配符指定上限：上限extends—使用时指定的类型必须是继承某个类，或者实现某个接口，即&lt;=；</li>
<li>通配符指定下限：下限super—使用时指定的类型不能小于操作的类，即&gt;=；</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
        <category>泛型</category>
      </categories>
      <tags>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title>注解</title>
    <url>/p/49545.html</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul>
<li>JDK5.0开始引入的一种注释机制。</li>
<li>代码中的特殊标记，这些标记可以在编译，类加载，运行时被读取，并执行相应的处理。通过使用Annotation，可以在不改变原有罗技的情况下，在源文件中嵌入一些补充信息。</li>
<li>Annotation可以像修饰符一样被使用，可用于修饰包，类，构造器，方法，成员变量，参数，局部变量的声明。</li>
</ul>
<a id="more"></a>

<h1 id="常用Annotation示例"><a href="#常用Annotation示例" class="headerlink" title="常用Annotation示例"></a>常用Annotation示例</h1><ul>
<li><strong>@Override：</strong>限定重写父类方法，该注解<strong>只能用于方法</strong>；</li>
<li><strong>@Deprecated：</strong>用于表示所修饰的元素（类、方法等）已过时。通常是因为所修饰的结构危险或存在更好的选择；</li>
<li><strong>@SuppressWarnings：</strong>抑制编译器警告。</li>
</ul>
<h2 id="Override使用"><a href="#Override使用" class="headerlink" title="@Override使用"></a>@Override使用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">annotationTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person(<span class="string">&quot;Lena&quot;</span>,<span class="number">15</span>);</span><br><span class="line">        p.walk();</span><br><span class="line">        Student s = <span class="keyword">new</span> Student(<span class="string">&quot;Cindy&quot;</span>,<span class="number">12</span>);</span><br><span class="line">        s.walk();</span><br><span class="line">        s.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;人走路&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;人吃饭&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Info</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Info</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">walk</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;学生走路&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;22222&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">人走路</span><br><span class="line">学生走路</span><br><span class="line"><span class="number">22222</span></span><br></pre></td></tr></table></figure>
<p><strong>注：</strong>如果去掉@Override，则编译的时候不会报错。</p>
<h2 id="Deprecated使用"><a href="#Deprecated使用" class="headerlink" title="@Deprecated使用"></a>@Deprecated使用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.util.Date date = <span class="keyword">new</span> java.util.Date(<span class="number">1992</span>,<span class="number">12</span>,<span class="number">5</span>);<span class="comment">//已过时，但是可以使用</span></span><br><span class="line">System.out.println(date);<span class="comment">//Thu Jan 05 00:00:00 CST 3893</span></span><br></pre></td></tr></table></figure>
<p><strong>注：</strong>过时还能够使用。</p>
<h2 id="SuppressWarnings使用"><a href="#SuppressWarnings使用" class="headerlink" title="@SuppressWarnings使用"></a>@SuppressWarnings使用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings(&quot;unused&quot;)</span></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">9</span>;</span><br></pre></td></tr></table></figure>
<p>指示编译器去忽略注解中声明的警告。声明了一个新的变量int，如果没有使用，在IDEA中会显示灰色。使用@SuppressWarnings(“unused”)之后变成正常黑色。</p>
<p>未注解：</p>
<p><img src="/p/Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201230205621901.png" alt="image-20201230205621901"></p>
<p>注解后：</p>
<p><img src="/p/Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20201230205638577.png" alt="image-20201230205638577"></p>
<h1 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h1><ul>
<li>自定义新的注解类型使用@interface关键字。</li>
<li>自定义注解自动继承了java.lang.annotation.Annotation接口。</li>
<li>Annotation的成员变量在Annotation定义中以无参数方法的形式来声明。其方法名和返回值定义了该成员的名字和类型，称之为配置参数。类型只能是8种基本数据类型、String类型、enum类型、Annotation类型、以上所有类型的数组。</li>
<li>只有一个成员变量时，建议使用value。</li>
<li>可以指定成员的默认值，使用default定义。</li>
<li>如果自定义的注解没有成员，表明是一个<strong>标识作用</strong>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> myAnnotation&#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;<span class="comment">//成员变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@myAnnotation(value = &quot;hi&quot;)</span><span class="comment">//必须给成员变量赋值</span></span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@myAnnotation(&quot;hi&quot;)</span><span class="comment">//必须给成员变量赋值</span></span><br></pre></td></tr></table></figure>
<p>或者可以指定成员的默认值，使用default定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> myAnnotation&#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> &quot;hi&quot;</span>;<span class="comment">//成员变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@myAnnotation()</span><span class="comment">//使用默认值</span></span><br></pre></td></tr></table></figure>
<h1 id="JDK提供的4种元注解"><a href="#JDK提供的4种元注解" class="headerlink" title="JDK提供的4种元注解"></a>JDK提供的4种元注解</h1><ul>
<li>JDK中的元Annotation用于修饰其他Annotation定义</li>
<li>JDK5.0提供了4个元注解：@Retention、@Documented、@Target、@Inherited</li>
</ul>
<h2 id="4个元注解的解释说明"><a href="#4个元注解的解释说明" class="headerlink" title="4个元注解的解释说明"></a>4个元注解的解释说明</h2><h3 id="Retention："><a href="#Retention：" class="headerlink" title="@Retention："></a><strong>@Retention：</strong></h3><p>标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。</p>
<p>有3种状态：</p>
<ul>
<li><strong>SOURCE</strong>：Annotations are to be discarded by the compiler.</li>
<li><strong>CLASS：**</strong>默认保存状态**。Annotations are to be recorded in the class file by the compiler but need not be retained by the VM at run time.  This is the default behavior.</li>
<li><strong>RUNTIME：只有声明为RUNTIME的注解才能通过反射获取</strong>。Annotations are to be recorded in the class file by the compiler and retained by the VM at run time, so they may be read reflectively.</li>
</ul>
<h3 id="Target："><a href="#Target：" class="headerlink" title="@Target："></a><strong>@Target：</strong></h3><p>用于指定被修饰的Annotation能用于修饰哪些程序元素。@Target也有一个成员变量。</p>
<ul>
<li><strong>TYPE：</strong>接口、类、枚举、注解</li>
<li><strong>FIELD：</strong>字段、枚举的常量</li>
<li><strong>METHOD：</strong>方法</li>
<li><strong>PARAMETER：</strong>方法参数</li>
<li><strong>CONSTRUCTOR：</strong>构造器</li>
<li><strong>LOCAL_VARIABLE：</strong>局部变量</li>
<li><strong>ANNOTATION_TYPE：</strong>注解</li>
<li><strong>PACKAGE：</strong>包</li>
</ul>
<p><strong>注：</strong>以上两个使用较多</p>
<h3 id="Documented："><a href="#Documented：" class="headerlink" title="@Documented："></a><strong>@Documented：</strong></h3><p>表示所修饰的注解在被javadoc解析时，是否包含在javadoc（用户文档）中。</p>
<h3 id="Inherited："><a href="#Inherited：" class="headerlink" title="@Inherited："></a><strong>@Inherited：</strong></h3><p>被修饰的Annotation将具有继承性。如果某个类使用了被@Inherited修饰的Annotation，则其子类将自动具有该注释。</p>
<h1 id="通过反射获取注解信息"><a href="#通过反射获取注解信息" class="headerlink" title="通过反射获取注解信息"></a>通过反射获取注解信息</h1><p>后续补充</p>
<h1 id="JDK8种注解的新特性"><a href="#JDK8种注解的新特性" class="headerlink" title="JDK8种注解的新特性"></a>JDK8种注解的新特性</h1><h2 id="可重复注解"><a href="#可重复注解" class="headerlink" title="可重复注解"></a>可重复注解</h2><h2 id="类型注解"><a href="#类型注解" class="headerlink" title="类型注解"></a>类型注解</h2>]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
        <category>注解</category>
      </categories>
      <tags>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title>线程的安全问题</title>
    <url>/p/55922.html</url>
    <content><![CDATA[<a id="more"></a>]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>线程的生命周期</title>
    <url>/p/37913.html</url>
    <content><![CDATA[<h4 id="线程的5种状态："><a href="#线程的5种状态：" class="headerlink" title="线程的5种状态："></a>线程的5种状态：</h4><p>JDK种使用Thread.state类定义了线程的5种状态：</p>
<a id="more"></a>

<ol>
<li><strong>新建：</strong>当一个Thread类或者其子类的对象被声明并创建时，新生的线程对象属于新建状态；</li>
<li><strong>就绪：</strong>处于新建状态的线程被start之后，将进入线程队列等待CPU世间品，此时已具备运行的条件，但未被分配到CPU资源；</li>
<li><strong>运行：</strong>当就绪的线程被调度获得CPU资源时，便进入了运行状态，run()方法提供了该线程的操作和使用；</li>
<li><strong>阻塞：</strong>在某种特殊情况下，被人挂起或进行I/O操作时，让出CPU并临时终端自己的执行，进入阻塞状态；阻塞状态是一个临时状态，不可以作为最终状态，线程最终状态都是死亡；</li>
<li><strong>死亡：</strong>完成工作或者被强行退出或者出现异常导致线程结束。</li>
</ol>
<p><img src="/p/blog\picture\线程状态转换.png"></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>线程通信</title>
    <url>/p/27168.html</url>
    <content><![CDATA[<a id="more"></a>

<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>​    线程和线程之间并非相互独立的个体，它们彼此之间需要相互通信和协作。如：线程执行先后顺序、获取某个线程执行的结果等等。</p>
<!--more-->

<h2 id="经典例题1：交替打印问题"><a href="#经典例题1：交替打印问题" class="headerlink" title="经典例题1：交替打印问题"></a>经典例题1：交替打印问题</h2><p>​    两个线程交替打印1-100</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="synchronized-wait-notify-方法"><a href="#synchronized-wait-notify-方法" class="headerlink" title="synchronized wait() notify()方法"></a>synchronized wait() notify()方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number = <span class="number">1</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line"></span><br><span class="line">                notify();</span><br><span class="line">                <span class="keyword">if</span> (number &lt;= <span class="number">100</span>) &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + number);</span><br><span class="line">                    number++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommunicationTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Number num = <span class="keyword">new</span> Number();</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(num);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(num);</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(num);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解析：</strong>①wait()一旦执行，当前线程就进入阻塞状态，并释放同步监视器；</p>
<p>​           ②notify()一旦执行，就会唤醒被wait的一个线程。如果有多个线程被wait，则唤醒优先级高的那个；</p>
<p>​           ③notifyAll()一旦执行，就会唤醒被wait的所有线程。</p>
<p>​           <strong>注：</strong>这些方法的调用只能在同步代码块或者同步方法中。</p>
<p>​           <strong>注：</strong>这三个方法的调用者必须是同步代码块或者同步方法中的同步监视器，否则会出现IllegalMonitorStateException异常。因为所有的同步监视器都要能够调用这三个方法，所以这三个方法都定义在超类Object中。</p>
<p>通俗来说，假设首先抢到同步监视器的是线程t1，那么在它执行完打印“1”之后，就被wait了（阻塞），并且释放同步监视器。此时，线程t2获得同步监视器，进入run方法中执行代码，当执行到notify的时候，则唤醒被wait了的线程t1，然后继续执行打印“2”，然后也被wait（阻塞），释放同步监视器。此时，线程t1获得同步监视器……直至100个数打印完毕。</p>
<h3 id="sleep-和wait-的异同"><a href="#sleep-和wait-的异同" class="headerlink" title="sleep()和wait()的异同"></a>sleep()和wait()的异同</h3><p>相同点：一旦执行方法，都可以使得线程进入阻塞状态。</p>
<p>不同点：</p>
<ol>
<li><strong>两个方法声明的位置不同</strong>：Thread类中声明了sleep()方法，Object类中声明了wait()方法。</li>
<li><strong>调用的方法不一样</strong>：sleep()可以在任何需要的场景下使用；wait()只能在同步代码块或者同步方法中使用。</li>
<li><strong>关于是否释放同步监视器的问题：</strong>如果两个方法都使用在同步代码块和同步方法中，sleep()不会释放，而wait()会释放同步监视器。</li>
</ol>
<h3 id="经典例题2：生产者-消费者问题"><a href="#经典例题2：生产者-消费者问题" class="headerlink" title="经典例题2：生产者/消费者问题"></a>经典例题2：生产者/消费者问题</h3><p>生产者将产品交给店员，而消费者从店员出取走产品，店员一次只能持有固定数量的产品，如果生产者始图生产更多的产品，店员会叫生产者停一下，如果店中有空位放置产品了再通知生产者继续生产；如果店里没有产品了，店员会告诉消费者停一下，如果有产品了再通知消费者来购买产品。</p>
<h3 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h3><p><strong>分析：</strong>多线程问题，多个线程为生产者线程、消费者线程，至少两个；有共享数据产品数量，可能存在线程安全问题；使用同步机制来解决线程安全问题；涉及线程通信问题。</p>
<p><strong>实现代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//店员</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clerk</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> productNum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">produceProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (productNum &lt; <span class="number">20</span>) &#123;</span><br><span class="line">            productNum++;</span><br><span class="line">            notifyAll();</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:生产第&quot;</span> + productNum + <span class="string">&quot;个产品&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">consumeProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (productNum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:消费第&quot;</span> + productNum + <span class="string">&quot;个产品&quot;</span>);</span><br><span class="line">            productNum--;</span><br><span class="line">            notifyAll();</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生产者----必须对应一个店员</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Clerk clerk = <span class="keyword">new</span> Clerk();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(Clerk clerk)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.clerk = clerk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            clerk.produceProduct();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者----必须对应一个店员</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Clerk clerk = <span class="keyword">new</span> Clerk();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(Clerk clerk)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.clerk = clerk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">20</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            clerk.consumeProduct();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Clerk c = <span class="keyword">new</span> Clerk();</span><br><span class="line">        Producer p1 = <span class="keyword">new</span> Producer(c);</span><br><span class="line">        p1.setName(<span class="string">&quot;生产者1&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Consumer c1 = <span class="keyword">new</span> Consumer(c);</span><br><span class="line">        c1.setName(<span class="string">&quot;消费者1&quot;</span>);</span><br><span class="line">        Consumer c2 = <span class="keyword">new</span> Consumer(c);</span><br><span class="line">        c2.setName(<span class="string">&quot;消费者2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        p1.start();</span><br><span class="line">        c1.start();</span><br><span class="line">        c2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程</title>
    <url>/p/52560.html</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul>
<li>网络编程的目的：直接或间接的通过网络协议与其他计算机实现数据交换，进行通讯；</li>
<li>主要的问题：<ul>
<li>如何准确定位网络上一台或多台主机：定位主机上的特定的应用（进程）—–&gt; IP和端口号</li>
<li>如果进行可靠高效的数据传输—–&gt;网络通信协议</li>
</ul>
</li>
</ul>
<a id="more"></a> 

<h1 id="网络通信要素"><a href="#网络通信要素" class="headerlink" title="网络通信要素"></a>网络通信要素</h1><ul>
<li>IP和端口号</li>
<li>网络通信协议</li>
</ul>
<h2 id="通信要素一：IP和端口号"><a href="#通信要素一：IP和端口号" class="headerlink" title="通信要素一：IP和端口号"></a>通信要素一：IP和端口号</h2><p><strong>分类：</strong></p>
<ul>
<li>IPv4和IPv6</li>
<li>万维网和局域网</li>
</ul>
<h3 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h3><p><strong>InetAddress类</strong>：</p>
<ul>
<li>getByName()方法</li>
<li>getLocalHost()方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InetAddress inet1 = InetAddress.getByName(<span class="string">&quot;192.168.10.12&quot;</span>);<span class="comment">//ipv4：/192.168.10.12</span></span><br><span class="line">InetAddress inet2 = InetAddress.getByName(<span class="string">&quot;www.baidu.com&quot;</span>);<span class="comment">//域名：www.baidu.com/14.215.177.39</span></span><br><span class="line"></span><br><span class="line">InetAddress inet3 = InetAddress.getByName(<span class="string">&quot;127.0.01&quot;</span>);<span class="comment">//本地回环地址localhost/127.0.0.1</span></span><br><span class="line">InetAddress inet4 = InetAddress.getByName(<span class="string">&quot;localhost&quot;</span>);<span class="comment">//本地回环地址localhost/127.0.0.1</span></span><br><span class="line">InetAddress inet5 = InetAddress.getLocalHost();<span class="comment">//本地回环地址localhost/127.0.0.1</span></span><br></pre></td></tr></table></figure>
<ul>
<li>getHostAddress()：获取ip的地址</li>
<li>getHostName()：获取域名</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(inet2.getHostAddress());<span class="comment">//14.215.177.39</span></span><br><span class="line">System.out.println(inet2.getHostName());<span class="comment">//www.baidu.com</span></span><br></pre></td></tr></table></figure>
<h3 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h3><p>端口号标识正在计算机上运行的进程（程序）</p>
<ul>
<li>不同的进程有不同的端口号</li>
<li>规定为1个16位的整数0-65535</li>
<li>端口分类：<ul>
<li><strong>公认端口</strong>：0-1023，被预先定义的服务器通信占用（HTTP占用端口80，FTP占用端口21，Telnet占用端口23等）</li>
<li><strong>注册端口</strong>：1024-49151，分配给用户进程或应用程序（Tomcat占用端口8080，MySQL占用端口3306，Oracle占用端口1521等）</li>
<li><strong>动态/私有端口</strong>：49152-65535</li>
</ul>
</li>
</ul>
<p><strong>端口号和IP地址的组合得出一个网络套接字：Socket</strong></p>
<h2 id="通信要素一：网络协议"><a href="#通信要素一：网络协议" class="headerlink" title="通信要素一：网络协议"></a>通信要素一：网络协议</h2><h3 id="TCP网络编程"><a href="#TCP网络编程" class="headerlink" title="TCP网络编程"></a>TCP网络编程</h3><p><strong>实现TCP网络编程例子一</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">//客户端发送信息给服务端，服务端显示在控制台上</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="comment">//客户端</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">client</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Socket socket = <span class="keyword">null</span>;</span><br><span class="line">        OutputStream os = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.创建Socket对象，指明服务器端的ip和端口号</span></span><br><span class="line">            InetAddress  inet = InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>);<span class="comment">//本机</span></span><br><span class="line">            socket = <span class="keyword">new</span> Socket(inet,<span class="number">1230</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2.获取一个输出流，用于输出数据</span></span><br><span class="line">            os = socket.getOutputStream();</span><br><span class="line">            <span class="comment">//3.写出数据</span></span><br><span class="line">            os.write(<span class="string">&quot;你好北京！&quot;</span>.getBytes());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//4.资源关闭</span></span><br><span class="line">            <span class="keyword">if</span> (os != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    os.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (socket != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="comment">//服务端</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">server</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">null</span>;</span><br><span class="line">        Socket socket = <span class="keyword">null</span>;</span><br><span class="line">        InputStreamReader isr = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1.创建服务器端的ServerSocket，指明自己的端口号</span></span><br><span class="line">            serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">1230</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2.调用accept()方法表示接收来自于客户端的socket</span></span><br><span class="line">            socket = serverSocket.accept();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3.获取输入流</span></span><br><span class="line">            InputStream is = socket.getInputStream();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//4.获取输入流中的数据</span></span><br><span class="line">            isr = <span class="keyword">new</span> InputStreamReader(is, <span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">            <span class="keyword">char</span>[] cbuf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">3</span>];</span><br><span class="line">            <span class="keyword">int</span> len;</span><br><span class="line">            <span class="keyword">while</span> ((len = isr.read(cbuf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">                String str = <span class="keyword">new</span> String(cbuf,<span class="number">0</span>,len);</span><br><span class="line">                System.out.print(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//资源关闭</span></span><br><span class="line">            <span class="keyword">if</span> (isr != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    isr.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (socket != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    socket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (serverSocket != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    serverSocket.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>实现TCP网络编程例子二</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//客户端发送文件给服务器，服务器将文件保存在本地。</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">client</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Socket socket = <span class="keyword">null</span>;</span><br><span class="line">    OutputStream os = <span class="keyword">null</span>;</span><br><span class="line">    FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建Socket对象，指明服务器端的ip和端口号</span></span><br><span class="line">        InetAddress inet = InetAddress.getLocalHost();</span><br><span class="line">        socket = <span class="keyword">new</span> Socket(inet, <span class="number">1111</span>);</span><br><span class="line">        <span class="comment">//2.获取一个输出流，用于保存文件数据</span></span><br><span class="line">        os = socket.getOutputStream();</span><br><span class="line">        <span class="comment">//3.将文件数据写出到2.的输出流</span></span><br><span class="line">        fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = fis.read(buf))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            os.write(buf,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.资源关闭</span></span><br><span class="line">    <span class="keyword">if</span> (fis != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fis.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (os != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            os.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (socket != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">server</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ServerSocket serverSocket = <span class="keyword">null</span>;</span><br><span class="line">    Socket socket = <span class="keyword">null</span>;</span><br><span class="line">    InputStream is = <span class="keyword">null</span>;</span><br><span class="line">    FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建服务器端的ServerSocket，指明自己的端口号</span></span><br><span class="line">        serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">1111</span>);</span><br><span class="line">        socket = serverSocket.accept();</span><br><span class="line">        <span class="comment">//2.调用accept()方法表示接收来自于客户端的socket</span></span><br><span class="line">        is = socket.getInputStream();</span><br><span class="line">        <span class="comment">//3.创建一个输入流，将is流中的数据保存在新文件里</span></span><br><span class="line">        fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;helloServerSave.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//4.将is流中的数据保存在fos流中</span></span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = is.read(buf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            fos.write(buf,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//5.资源关闭</span></span><br><span class="line">        <span class="keyword">if</span> (fos != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (is != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                is.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (socket != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (serverSocket != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                serverSocket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>实现TCP网络编程例子三</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从客户端发送文件给服务器，服务器保存到本地，并返回“发送成功”给客户端，并关闭相应的连接。</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">client</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Socket socket = <span class="keyword">null</span>;</span><br><span class="line">    OutputStream os = <span class="keyword">null</span>;</span><br><span class="line">    FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">    InputStream is = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建Socket对象，指明服务器端的ip和端口号</span></span><br><span class="line">        InetAddress inet = InetAddress.getLocalHost();</span><br><span class="line">        socket = <span class="keyword">new</span> Socket(inet, <span class="number">1111</span>);</span><br><span class="line">        <span class="comment">//2.获取一个输出流，用于保存文件数据</span></span><br><span class="line">        os = socket.getOutputStream();</span><br><span class="line">        <span class="comment">//3.将文件数据写出到2.的输出流</span></span><br><span class="line">        fis = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = fis.read(buf))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            os.write(buf,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;客户端：isInputShutdown=&quot;</span> + socket.isInputShutdown());</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端：isOutputShutdown=&quot;</span> + socket.isOutputShutdown());</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端：isClose=&quot;</span> + socket.isClosed());</span><br><span class="line"></span><br><span class="line">        socket.shutdownOutput();<span class="comment">//关闭数据输出</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;客户端：isInputShutdown=&quot;</span> + socket.isInputShutdown());</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端：isOutputShutdown=&quot;</span> + socket.isOutputShutdown());</span><br><span class="line">        System.out.println(<span class="string">&quot;客户端：isClose=&quot;</span> + socket.isClosed());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.接收服务器端的”发送成功“信息，并显示到控制台上</span></span><br><span class="line">        is = socket.getInputStream();</span><br><span class="line">        InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(is);</span><br><span class="line">        <span class="keyword">char</span>[] cbuf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">int</span> len_cubf;</span><br><span class="line">        <span class="keyword">while</span> ((len_cubf = isr.read(cbuf))!=-<span class="number">1</span>)&#123;</span><br><span class="line">            String str = <span class="keyword">new</span> String(cbuf, <span class="number">0</span>, len_cubf);</span><br><span class="line">            System.out.print(str);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5.资源关闭</span></span><br><span class="line">    <span class="keyword">if</span> (is != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            is.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fis != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fis.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (os != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            os.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (socket != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            socket.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">server</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ServerSocket serverSocket = <span class="keyword">null</span>;</span><br><span class="line">    Socket socket = <span class="keyword">null</span>;</span><br><span class="line">    InputStream is = <span class="keyword">null</span>;</span><br><span class="line">    FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">    OutputStream os = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建服务器端的ServerSocket，指明自己的端口号</span></span><br><span class="line">        serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">1111</span>);</span><br><span class="line">        socket = serverSocket.accept();</span><br><span class="line">        <span class="comment">//2.调用accept()方法表示接收来自于客户端的socket</span></span><br><span class="line">        is = socket.getInputStream();</span><br><span class="line">        <span class="comment">//3.创建一个输入流，将is流中的数据保存在新文件里</span></span><br><span class="line">        fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;helloServerSave.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//4.将is流中的数据保存在fos流中</span></span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = is.read(buf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            fos.write(buf,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;服务端：isInputShutdown=&quot;</span> + socket.isInputShutdown());</span><br><span class="line">        System.out.println(<span class="string">&quot;服务端：isOutputShutdown=&quot;</span> + socket.isOutputShutdown());</span><br><span class="line">        System.out.println(<span class="string">&quot;服务端：isClose=&quot;</span> + socket.isClosed());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//5.服务器端给客户端反馈</span></span><br><span class="line">        os = socket.getOutputStream();</span><br><span class="line">        os.write(<span class="string">&quot;发送成功！&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//6.资源关闭</span></span><br><span class="line">        <span class="keyword">if</span> (os != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                os.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fos != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (is != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                is.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (socket != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (serverSocket != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                serverSocket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">客户端：isInputShutdown&#x3D;false</span><br><span class="line">客户端：isOutputShutdown&#x3D;false</span><br><span class="line">客户端：isClose&#x3D;false</span><br><span class="line"></span><br><span class="line">客户端：isInputShutdown&#x3D;false</span><br><span class="line">客户端：isOutputShutdown&#x3D;true</span><br><span class="line">客户端：isClose&#x3D;false</span><br><span class="line">发送成功！</span><br></pre></td></tr></table></figure>
<p>服务端输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">服务端：isInputShutdown&#x3D;false</span><br><span class="line">服务端：isOutputShutdown&#x3D;false</span><br><span class="line">服务端：isClose&#x3D;false</span><br></pre></td></tr></table></figure>
<p><strong>说明：</strong></p>
<ul>
<li><p>在没有使用socket.shutdownOutput();之前，客户端的输出流是打开的，使用之后则关闭了。</p>
</li>
<li><p>调用Socket.shutdownOutput()后，禁用此套接字的输出流，对于 TCP 套接字，任何以前写入的数据都将被发送，并且后跟 TCP 的正常连接终止序列（即-1），之后，从另一端TCP套接字的输入流中读取数据时，如果到达输入流末尾而不再有数据可用，则返回 -1。</p>
</li>
</ul>
<p>注：详细细节后续再深入研究</p>
<h3 id="UDP网络编程"><a href="#UDP网络编程" class="headerlink" title="UDP网络编程"></a>UDP网络编程</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">//发送端</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sender</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    DatagramSocket socket = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line"></span><br><span class="line">    String str = <span class="string">&quot;我是发送端发来的数据。&quot;</span>;</span><br><span class="line">    <span class="keyword">byte</span>[] data = str.getBytes();</span><br><span class="line">    InetAddress inet = InetAddress.getLocalHost();</span><br><span class="line">    DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(data,<span class="number">0</span>,data.length,inet,<span class="number">1111</span>);<span class="comment">//数据打包</span></span><br><span class="line">    <span class="comment">//数据发送</span></span><br><span class="line">    socket.send(packet);</span><br><span class="line">    <span class="comment">//资源关闭</span></span><br><span class="line">    socket.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="comment">//接收端</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reciever</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    DatagramSocket socket = <span class="keyword">new</span> DatagramSocket(<span class="number">1111</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">100</span>];</span><br><span class="line">    DatagramPacket packet = <span class="keyword">new</span> DatagramPacket(buffer,buffer.length);</span><br><span class="line">    socket.receive(packet);<span class="comment">//接收数据包</span></span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="keyword">new</span> String(packet.getData(),<span class="number">0</span>,packet.getLength()));</span><br><span class="line"></span><br><span class="line">    socket.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接收端：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我是发送端发来的数据。</span><br></pre></td></tr></table></figure>
<h3 id="URL网络编程"><a href="#URL网络编程" class="headerlink" title="URL网络编程"></a>URL网络编程</h3><ul>
<li>URL（Uniform Resource Locator）：统一资源定位符</li>
<li>URL构成：**&lt;传输协议&gt;://&lt;主机名&gt;:&lt;端口号&gt;/&lt;文件名&gt;#片段名?参数列表**</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HttpURLConnection httpURLConnection = <span class="keyword">null</span>;</span><br><span class="line">InputStream is = <span class="keyword">null</span>;</span><br><span class="line">FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    URL url = <span class="keyword">new</span> URL(<span class="string">&quot;http://localhost:8080/sample/1.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">    httpURLConnection = (HttpURLConnection) url.openConnection();</span><br><span class="line"></span><br><span class="line">    httpURLConnection.connect();<span class="comment">//获取连接</span></span><br><span class="line"></span><br><span class="line">    is = httpURLConnection.getInputStream();</span><br><span class="line">    fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;2.jpg&quot;</span>);<span class="comment">//写在了当前工程下</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">while</span>((len = is.read(buf))!=-<span class="number">1</span>)&#123;</span><br><span class="line">        fos.write(buf,<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//关闭资源</span></span><br><span class="line">    <span class="keyword">if</span>(fos != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fos.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(is != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            is.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(httpURLConnection != <span class="keyword">null</span>)</span><br><span class="line">        httpURLConnection.disconnect();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
        <category>IO流</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>获取两个字符串中最大相同子串</title>
    <url>/p/7049.html</url>
    <content><![CDATA[<p><strong>问题：</strong>获取两个字符串中最大相同子串。比如：str1=”asfworlsdlaksfjhellokdhsld”,str2=”dfshelloflasdjflkdsjfldaslworldhhhhhhasjdskjdhkc”</p>
<a id="more"></a>

<p><strong>解法一：</strong>从短到长一次遍历长度较短的字符串，查看另一个字符串是否包含且长度为最大。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getMaxSubstring</span><span class="params">(String str1, String str2)</span></span>&#123;</span><br><span class="line">        String maxSubstring = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> str1Length = str1.length();</span><br><span class="line">        <span class="keyword">int</span> str2Length = str2.length();</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        String strTemp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (str1 != <span class="keyword">null</span> &amp;&amp; str2 != <span class="keyword">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (str1Length == str2Length)&#123;</span><br><span class="line">                <span class="keyword">if</span> (str1.contains(str2))&#123;</span><br><span class="line">                    <span class="keyword">return</span> str2;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (str1Length &lt; str2Length)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j =<span class="number">0</span> ; j &lt;= str1Length; j++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; j; i++) &#123;</span><br><span class="line">                        strTemp = str1.substring(i,j);</span><br><span class="line">                        <span class="keyword">if</span> (str2.contains(strTemp) &amp;&amp; strTemp.length() &gt; maxSubstring.length())&#123;</span><br><span class="line">                            maxSubstring = strTemp;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (str1Length &gt; str2Length)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= str2Length; j++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; j; i++) &#123;</span><br><span class="line">                        strTemp = str2.substring(i,j);</span><br><span class="line">                        <span class="keyword">if</span> (str1.contains(strTemp) &amp;&amp; strTemp.length() &gt; maxSubstring.length())&#123;</span><br><span class="line">                            maxSubstring = strTemp;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxSubstring;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>要将较短的字符串的所有子串从短到长遍历一遍，然后寻找最长的相同子串，这样耗时长，考虑先从最长的子串开始核查。</p>
<p><strong>解法二：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getMaxSubstring1</span><span class="params">(String str1, String str2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str1 != <span class="keyword">null</span> &amp;&amp; str2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> str1Length = str1.length();</span><br><span class="line">            <span class="keyword">int</span> str2Length = str2.length();</span><br><span class="line">            String maxStr = (str1Length &gt;= str2Length)? str1 : str2;</span><br><span class="line">            String minStr = (str1Length &lt; str2Length)? str1 : str2;</span><br><span class="line">            <span class="keyword">int</span> minStrLength = minStr.length();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">1</span>; len &lt;= minStrLength; len++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>,y = minStrLength-len; y &lt;= minStrLength; x++,y++)&#123;</span><br><span class="line">                    String substr = minStr.substring(x,y);</span><br><span class="line">                    <span class="keyword">if</span> (maxStr.contains(substr))&#123;</span><br><span class="line">                        <span class="keyword">return</span> substr;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>取短的字符串作为minStr，长的字符串作为maxStr。minStr从长到短依次列出子串拿去给maxStr查找。</p>
<p>其中minStr的子串可能的长度为1，2，3，…，minStr.length()。共计minStr.length()个，设定位len。</p>
<p>而针对提取出子串，需要用到substring()方法，这就需要确定startIndex和endIndex，其中startIndex从0开始，endIndex则需要从minStr.length()-第几次迭代长度len。</p>
<p>如果在maxStr中存在minStr提取出的子串，那么由于我们是依据子串从长到短进行查找的，那么找到的应该就是两个字符串最大相同子串。</p>
<p><strong>注：</strong>以上只适用于单个最大相同子串。如果有多个，则需要使用集合的概念。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
        <category>String类</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>获取一个字符串在另一个字符串中出现的次数</title>
    <url>/p/4524.html</url>
    <content><![CDATA[<p><strong>问题：</strong>获取一个字符串在另一个字符串中出现的次数。比如字符串“abkkcadkabkebfkabkskabdjahkjldghabab”中“ab”出现的次数。</p>
<a id="more"></a>

<p><strong>解法一：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringQ3</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String str1 = <span class="string">&quot;abkkcadkabkebfkabkskabdjahkjldghabab&quot;</span>;</span><br><span class="line">        String str2 = <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">        System.out.print(<span class="string">&quot;字符串&quot;</span> + str1 + <span class="string">&quot;中&quot;</span>);</span><br><span class="line">        System.out.println(str2 + <span class="string">&quot;出现几次？&quot;</span>);</span><br><span class="line">        System.out.println(getCount(str1, str2));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取str1中str2出现的次数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> str2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">(String str1, String str2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> str1Length = str1.length();</span><br><span class="line">        <span class="keyword">int</span> str2Length = str2.length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (str1Length &gt;= str2Length)&#123;</span><br><span class="line">            <span class="keyword">while</span> (str1.indexOf(str2) != -<span class="number">1</span>)&#123;</span><br><span class="line">                str1 = str1.substring(str1.indexOf(str2) + str2Length);</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>解法二：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCount1</span><span class="params">(String str1, String str2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> str1Length = str1.length();</span><br><span class="line">    <span class="keyword">int</span> str2Length = str2.length();</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (str1Length &gt;= str2Length)&#123;</span><br><span class="line">        <span class="keyword">while</span> ((index = str1.indexOf(str2,index)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            index += str2Length;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效率更高。因为没有频繁创建新对象。</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
        <category>String类</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>String</tag>
      </tags>
  </entry>
  <entry>
    <title>IO流</title>
    <url>/p/7580.html</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul>
<li>I/O是Input/Output的缩写，用于处理设备之间的数据传输。</li>
<li>Java中数据的输入输出都是以“流”的形式进行。</li>
<li>java.io中提供了各种“流”类和接口，用以获取不同种类的数据，并通过标准的方式输入或输出数据。</li>
</ul>
<a id="more"></a> 

<h2 id="Java-IO原理"><a href="#Java-IO原理" class="headerlink" title="Java IO原理"></a>Java IO原理</h2><ul>
<li>输入input：读取外部数据（磁盘、光盘等存储设备的数据）到程序（内存）中；</li>
<li>输出output：将程序（内存）数据输出到磁盘、光盘等存储设备中。</li>
</ul>
<h2 id="IO流的分类"><a href="#IO流的分类" class="headerlink" title="IO流的分类"></a>IO流的分类</h2><ul>
<li>按照操作<strong>数据单位</strong>不同分为：字节流（8bit），字符流（16bit）</li>
<li>按照数据流的<strong>流向</strong>不同分为：输入流、输出流</li>
<li>按照流的<strong>角色</strong>不同分为：节点流，处理流<ul>
<li>节点流：直接对目标设备进行操作的流</li>
<li>处理流：对节点流进行连接和封装，生成功能更加强大的流</li>
</ul>
</li>
</ul>
<p>Java中的IO流都是从以下4个抽象基类派生的：</p>
<table>
<thead>
<tr>
<th align="left">【抽象基类】</th>
<th>字节流</th>
<th>字符流</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>输入流</strong></td>
<td>InputStream</td>
<td>Reader</td>
</tr>
<tr>
<td align="left"><strong>输出流</strong></td>
<td>OutputStream</td>
<td>Writer</td>
</tr>
</tbody></table>
<h1 id="IO流体系"><a href="#IO流体系" class="headerlink" title="IO流体系"></a>IO流体系</h1><table>
<thead>
<tr>
<th>分类</th>
<th>字节输入流</th>
<th>字节输出流</th>
<th>字符输入流</th>
<th>字符输出流</th>
</tr>
</thead>
<tbody><tr>
<td><strong>抽象基类</strong></td>
<td>InputStream</td>
<td>OutputStream</td>
<td>Reader</td>
<td>Writer</td>
</tr>
<tr>
<td><strong>访问文件</strong></td>
<td><strong>FileInputStream</strong></td>
<td><strong>FileOutputStream</strong></td>
<td><strong>FileReader</strong></td>
<td><strong>FileWriter</strong></td>
</tr>
<tr>
<td>访问数组</td>
<td>ByteArrayInputStream</td>
<td>ByteArrayOutputStream</td>
<td>CharArrayReader</td>
<td>CharArrayWriter</td>
</tr>
<tr>
<td>访问管道</td>
<td>PipedInputStream</td>
<td>PipedOutputStream</td>
<td>PipedReader</td>
<td>PipedWriter</td>
</tr>
<tr>
<td>访问字符串</td>
<td></td>
<td></td>
<td>StringReader</td>
<td>StringWriter</td>
</tr>
<tr>
<td><strong>缓冲流</strong></td>
<td><strong>BufferedInputStream</strong></td>
<td><strong>BufferedOutputStream</strong></td>
<td><strong>BufferedReader</strong></td>
<td><strong>BufferedWriter</strong></td>
</tr>
<tr>
<td><strong>转换流</strong></td>
<td></td>
<td></td>
<td><strong>InputStreamReader</strong></td>
<td><strong>OutputStreamWriter</strong></td>
</tr>
<tr>
<td><strong>对象流</strong></td>
<td><strong>ObjectInputStream</strong></td>
<td><strong>ObjectOutputStream</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>FilterInputStream</td>
<td>FilterOutputStream</td>
<td>FilterReader</td>
<td>FilterWriter</td>
</tr>
<tr>
<td>打印流</td>
<td></td>
<td>PrintStream</td>
<td></td>
<td></td>
</tr>
<tr>
<td>推回输入流</td>
<td>PushbackInputStream</td>
<td></td>
<td>PushbackReader</td>
<td></td>
</tr>
<tr>
<td>特殊流</td>
<td>DataInputStream</td>
<td>DataOutputStream</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="访问文件"><a href="#访问文件" class="headerlink" title="访问文件"></a>访问文件</h2><p><strong>注：</strong>对于文本文件(.txt,.java,.c,.cpp……)，使用字符流处理(.jpg,.png,doc……)；对于非文本文件，使用字节流处理。</p>
<ul>
<li><p><strong>FileInputStream</strong></p>
</li>
<li><p><strong>FileOutputStream</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.实例化File类的对象，指明要操作的文件</span></span><br><span class="line">File srcFile = <span class="keyword">new</span> File(<span class="string">&quot;1.jpg&quot;</span>);</span><br><span class="line">File dstFile = <span class="keyword">new</span> File(<span class="string">&quot;2.jpg&quot;</span>);</span><br><span class="line"><span class="comment">//2.提供具体的流</span></span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(srcFile);</span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(dstFile);</span><br><span class="line"><span class="comment">//3.数据读入/写出</span></span><br><span class="line"><span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="keyword">while</span>((len = fis.read(buf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">//每次写出len个字节</span></span><br><span class="line">    fos.write(buf,<span class="number">0</span>,len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4.流的关闭操作</span></span><br><span class="line">fis.close();</span><br><span class="line">fos.close();</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>FileReader</strong></li>
</ul>
<p>方式一：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.实例化File类的对象，指明要操作的文件</span></span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line"><span class="comment">//2.提供具体的流</span></span><br><span class="line">FileReader fileReader = <span class="keyword">new</span> FileReader(file);</span><br><span class="line"><span class="comment">//3.数据读入</span></span><br><span class="line"><span class="comment">//read():返回读入的一个字符，如果达到文件莫问，返回-1</span></span><br><span class="line"><span class="keyword">int</span> read = fileReader.read();</span><br><span class="line"><span class="keyword">while</span>(read != -<span class="number">1</span>)&#123;</span><br><span class="line">    System.out.print((<span class="keyword">char</span>)read);<span class="comment">//helloworld</span></span><br><span class="line">    read = fileReader.read();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4.流的关闭操作</span></span><br><span class="line">fileReader.close();</span><br></pre></td></tr></table></figure>
<p>方式二：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.实例化File类的对象，指明要操作的文件</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//2.提供具体的流</span></span><br><span class="line">        FileReader fileReader = <span class="keyword">new</span> FileReader(file);</span><br><span class="line">        <span class="comment">//3.数据读入</span></span><br><span class="line">        <span class="comment">//read(char[] cbuf):返回每次读入cubf字符的个数，如果达到文件莫问，返回-1</span></span><br><span class="line">        <span class="keyword">char</span>[] cbuf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = fileReader.read(cbuf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//正确写法之一</span></span><br><span class="line"><span class="comment">//            for (int i = 0; i &lt; len; i++) &#123;</span></span><br><span class="line"><span class="comment">//                System.out.print(cbuf[i]);//helloworld123</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">            <span class="comment">//错误的写法：helloworld123ld</span></span><br><span class="line"><span class="comment">//            for (int i = 0; i &lt; len; i++) &#123;</span></span><br><span class="line"><span class="comment">//                System.out.print(cbuf[i]);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">            <span class="comment">//错误的写法二：和上面错误的写法类似</span></span><br><span class="line"><span class="comment">//            String str = new String(cbuf);</span></span><br><span class="line"><span class="comment">//            System.out.print(str);//helloworld123ld</span></span><br><span class="line">            <span class="comment">//改为正确的写法之二</span></span><br><span class="line">            String str = <span class="keyword">new</span> String(cbuf,<span class="number">0</span>,len);</span><br><span class="line">            System.out.print(str);<span class="comment">//helloworld123</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.流的关闭操作</span></span><br><span class="line">        fileReader.close();</span><br></pre></td></tr></table></figure>
<p><strong>注：</strong>读入的文件一定要存在，否则会报FileNotFoundException。</p>
<ul>
<li><strong>FileWriter</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">/<span class="number">1.</span>实例化File类的对象，指明要操作的文件</span><br><span class="line">File file = <span class="keyword">new</span> File(<span class="string">&quot;hi.txt&quot;</span>);</span><br><span class="line"><span class="comment">//2.提供具体的流</span></span><br><span class="line">FileWriter fw = <span class="keyword">new</span> FileWriter(file,<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//3.数据写出</span></span><br><span class="line">fw.write(<span class="string">&quot;Hi, Joe!&quot;</span>);</span><br><span class="line">fw.write(<span class="string">&quot;!!!!&quot;</span>);<span class="comment">//Hi, Joe!!!!!</span></span><br><span class="line">fw.write(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">fw.write(<span class="string">&quot;Hi, Jack!&quot;</span>);</span><br><span class="line"><span class="comment">//4.流的关闭操作</span></span><br><span class="line">fw.close();</span><br></pre></td></tr></table></figure>
<p><strong>注：</strong>输出操作，对应的File可以不存在，不会报异常。</p>
<p>如果不存在，在输出的过程中，会自动创建此文件。</p>
<p>如果存在：</p>
<p>​    如果流使用的构造器是FileWriter(file,false) / FileWriter(file)，则是对原有文件的覆盖；</p>
<p>​    如果流使用的构造器是FileWriter(file,true)，则是在原有文件的基础上进行append操作。</p>
<p><strong>输入输出：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.实例化File类的对象，指明要操作的文件</span></span><br><span class="line">File srcFile = <span class="keyword">new</span> File(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">File dstFile = <span class="keyword">new</span> File(<span class="string">&quot;hi.txt&quot;</span>);</span><br><span class="line"><span class="comment">//2.提供具体的流</span></span><br><span class="line">FileReader fr = <span class="keyword">new</span> FileReader(srcFile);</span><br><span class="line">FileWriter fw = <span class="keyword">new</span> FileWriter(dstFile);</span><br><span class="line"><span class="comment">//3.数据读入/写出</span></span><br><span class="line"><span class="keyword">char</span>[] cbuf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="keyword">while</span>((len = fr.read(cbuf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">//每次写出len个字符</span></span><br><span class="line">    fw.write(cbuf,<span class="number">0</span>,len);<span class="comment">//helloworld123</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4.流的关闭操作</span></span><br><span class="line">fr.close();</span><br><span class="line">fw.close();</span><br></pre></td></tr></table></figure>
<h2 id="缓冲流（处理流）"><a href="#缓冲流（处理流）" class="headerlink" title="缓冲流（处理流）"></a>缓冲流（处理流）</h2><p><strong>注：</strong></p>
<ol>
<li>提供流的读取、写入的速度；</li>
<li>先关闭外层的流，再关闭内层的流；</li>
<li>关闭外层流的同时，内层流也会自动关闭，内层流的关闭可以忽略。</li>
</ol>
<ul>
<li><strong>BufferedInputStream</strong></li>
<li><strong>BufferedOutputStream</strong></li>
<li><strong>BufferedReader</strong></li>
<li><strong>BufferedWriter</strong></li>
</ul>
<h3 id="速度对比"><a href="#速度对比" class="headerlink" title="速度对比"></a>速度对比</h3><p>使用<strong>FileInputStream</strong>和<strong>FileOutputStream</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyFile</span><span class="params">(String srcPath, String dstPath)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//1.实例化File类的对象，指明要操作的文件</span></span><br><span class="line">    File srcFile = <span class="keyword">new</span> File(srcPath);</span><br><span class="line">    File dstFile = <span class="keyword">new</span> File(dstPath);</span><br><span class="line">    <span class="comment">//2.提供具体的流</span></span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(srcFile);</span><br><span class="line">    FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(dstFile);</span><br><span class="line">    <span class="comment">//3.数据读入/写出</span></span><br><span class="line">    <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">while</span>((len = fis.read(buf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//每次写出len个字节</span></span><br><span class="line">        fos.write(buf,<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.流的关闭操作</span></span><br><span class="line">    fis.close();</span><br><span class="line">    fos.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String srcPath= <span class="string">&quot;1.jpg&quot;</span>;</span><br><span class="line">String dstPath = <span class="string">&quot;2.jpg&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">copyFile(srcPath,dstPath);</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;复制文件耗时：&quot;</span> + (end-start));<span class="comment">//55</span></span><br></pre></td></tr></table></figure>
<p>使用<strong>BufferedInputStream</strong>和<strong>BufferedOutputStream</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyFile1</span><span class="params">(String srcPath, String dstPath)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//1.造文件</span></span><br><span class="line">        File srcFile = <span class="keyword">new</span> File(srcPath);</span><br><span class="line">        File dstFile = <span class="keyword">new</span> File(dstPath);</span><br><span class="line">        <span class="comment">//2.造流</span></span><br><span class="line">        <span class="comment">//2.1造节点流</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(srcFile);</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(dstFile);</span><br><span class="line">        <span class="comment">//2.2造缓冲流</span></span><br><span class="line">        BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(fis);</span><br><span class="line">        BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(fos);</span><br><span class="line">        <span class="comment">//3.读取、写入</span></span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = bis.read(buf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            bos.write(buf,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.资源关闭</span></span><br><span class="line">        bis.close();</span><br><span class="line">        bos.close();</span><br><span class="line"><span class="comment">//        fis.close();</span></span><br><span class="line"><span class="comment">//        fos.close();</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String srcPath= <span class="string">&quot;1.jpg&quot;</span>;</span><br><span class="line">String dstPath = <span class="string">&quot;2.jpg&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">copyFile1(srcPath,dstPath);</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;复制文件耗时：&quot;</span> + (end-start));<span class="comment">//3</span></span><br></pre></td></tr></table></figure>
<p>缓冲流之所以速度变快，是因为在内部定义了一个缓存区DEFAULT_BUFFER_SIZE，默认大小为8192，当从存储介质中读取数据的时候，先将数据存储到缓冲区，等缓冲区满了之后一并送入内存中。</p>
<p>使用<strong>BufferedReader</strong>和<strong>BufferedWriter</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">        BufferedWriter bw = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="keyword">new</span> File(<span class="string">&quot;hello.txt&quot;</span>)));</span><br><span class="line">            bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="keyword">new</span> File(<span class="string">&quot;hello1.txt&quot;</span>)));</span><br><span class="line">            <span class="comment">//方式一</span></span><br><span class="line"><span class="comment">//            char[] cbuf = new char[5];</span></span><br><span class="line"><span class="comment">//            int len;</span></span><br><span class="line"><span class="comment">//            while ((len = br.read(cbuf)) != -1)&#123;</span></span><br><span class="line"><span class="comment">//                bw.write(cbuf,0,len);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">            <span class="comment">//方式二</span></span><br><span class="line">            String data;</span><br><span class="line">            <span class="keyword">while</span> ((data = br.readLine()) != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">//换行方法一</span></span><br><span class="line"><span class="comment">//                bw.write(data);//不包含换行符</span></span><br><span class="line"><span class="comment">//                bw.write(&quot;\n&quot;);</span></span><br><span class="line">                <span class="comment">//换行方法二</span></span><br><span class="line">                bw.write(data);</span><br><span class="line">                bw.newLine();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (br != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    br.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (bw != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    bw.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h2 id="转换流（处理流）"><a href="#转换流（处理流）" class="headerlink" title="转换流（处理流）"></a>转换流（处理流）</h2><ul>
<li><strong>InputStreamReader</strong>：字节的输入流 —–&gt; 字符的输入流</li>
<li><strong>OutputStreamReader</strong>：字符的输出流 —–&gt; 字节的输出流</li>
</ul>
<p><strong>注：</strong>字节、字符数组 —–&gt; 字符、字符数组是解码，逆过程为编码。</p>
<p><strong>字节的输入流 —–&gt; 字符的输入流：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(file);<span class="comment">//字节流</span></span><br><span class="line"><span class="comment">//参数2指明了字符集，具体使用哪个字符集，取决于读取的文件保存时使用的字符集</span></span><br><span class="line">InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(fis,<span class="string">&quot;UTF-8&quot;</span>);<span class="comment">//转换为字符流</span></span><br><span class="line"><span class="keyword">char</span>[] cbuf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> len;</span><br><span class="line"><span class="keyword">while</span>((len = isr.read(cbuf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">    String str = <span class="keyword">new</span> String(cbuf,<span class="number">0</span>,len);</span><br><span class="line">    System.out.print(str);</span><br><span class="line">&#125;</span><br><span class="line">isr.close();</span><br></pre></td></tr></table></figure>
<p><strong>将使用“UTF-8”保存的文本文件修改为使用“gbk”保存的文本为文件：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.造文件</span></span><br><span class="line">        File file1 = <span class="keyword">new</span> File(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">        File file2 = <span class="keyword">new</span> File(<span class="string">&quot;hello_gbk.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//2.造流</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(file1);<span class="comment">//字节流</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(file2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//参数2指明了字符集，具体使用哪个字符集，取决于读取的文件保存时使用的字符集</span></span><br><span class="line">        InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(fis,<span class="string">&quot;UTF-8&quot;</span>);<span class="comment">//转换为字符流</span></span><br><span class="line">        OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(fos, <span class="string">&quot;gbk&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.读写过程</span></span><br><span class="line">        <span class="keyword">char</span>[] cbuf = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = isr.read(cbuf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            osw.write(cbuf,<span class="number">0</span>,len);</span><br><span class="line"><span class="comment">//            String str = new String(cbuf,0,len);</span></span><br><span class="line"><span class="comment">//            System.out.print(str);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//4.关闭流</span></span><br><span class="line">        isr.close();</span><br><span class="line">        osw.close();</span><br></pre></td></tr></table></figure>
<h2 id="标准输入流、输出流（处理流）"><a href="#标准输入流、输出流（处理流）" class="headerlink" title="标准输入流、输出流（处理流）"></a>标准输入流、输出流（处理流）</h2><ul>
<li><strong>System.in</strong>：标准的输入流，默认从键盘输入</li>
<li><strong>System.out</strong>：标准的输出流，默认从控制台输出</li>
</ul>
<p>举例：从键盘输入字符串，要求将读取的整行字符串转成大写输出，然后继续进行输入操作，知道输入”e“或者”exit“时退出程序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        InputStreamReader fis = <span class="keyword">new</span> InputStreamReader(System.in);</span><br><span class="line">        br = <span class="keyword">new</span> BufferedReader(fis);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println();</span><br><span class="line">            System.out.print(<span class="string">&quot;请输入字符串：&quot;</span>);</span><br><span class="line">            String data = br.readLine();</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;e&quot;</span>.equalsIgnoreCase(data) || <span class="string">&quot;exit&quot;</span>.equalsIgnoreCase(data))&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;程序结束！&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                String s = data.toUpperCase();</span><br><span class="line">                System.out.print(<span class="string">&quot;转换为大写：&quot;</span> + s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (br != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                br.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="打印流（处理流）"><a href="#打印流（处理流）" class="headerlink" title="打印流（处理流）"></a>打印流（处理流）</h2><p>将基本类型的数据格式转换为字符串输出</p>
<ul>
<li><strong>printStream</strong></li>
<li><strong>printWriter</strong></li>
</ul>
<p>提供了一系列重载的print()和println()方法</p>
<p>举例：在外部文件里打印出1-255的字符</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PrintStream ps = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;print.txt&quot;</span>);</span><br><span class="line">    <span class="comment">//创建打印输出流,自动刷新</span></span><br><span class="line">    ps = <span class="keyword">new</span> PrintStream(fos, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">if</span> (ps != <span class="keyword">null</span>)&#123;</span><br><span class="line">        System.setOut(ps);<span class="comment">//把标准输出流（控制台输出）改成文件输出</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">255</span>; i++) &#123;</span><br><span class="line">        System.out.print((<span class="keyword">char</span>)i);<span class="comment">//输出ASCII字符</span></span><br><span class="line">        <span class="keyword">if</span> (i % <span class="number">50</span> == <span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println();<span class="comment">//每50个字符换行</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ps.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数据流（处理流）"><a href="#数据流（处理流）" class="headerlink" title="数据流（处理流）"></a>数据流（处理流）</h2><p>用于读取或写出<strong>基本数据类</strong>的变量或者<strong>字符串</strong>。</p>
<p>DataInputStream</p>
<p>DataOutputStream</p>
<p>举例：</p>
<p><strong>写：</strong>将内存中的字符串、基本数据类型变量写出到文件中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DataOutputStream dos = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    dos = <span class="keyword">new</span> DataOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">&quot;output.txt&quot;</span>)));</span><br><span class="line"></span><br><span class="line">    dos.writeUTF(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">    dos.flush();<span class="comment">//刷新，一旦执行，将数据写入文件中</span></span><br><span class="line">    dos.write(<span class="number">23</span>);</span><br><span class="line">    dos.flush();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (dos != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            dos.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>读：</strong>将文件中存储的基本数据类型变量、字符串读取到内存中，保存在变量中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DataInputStream dis = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    dis = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;output.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注：读取数据的顺序要与当初写入文件时写入的顺序一致</span></span><br><span class="line">    String name = dis.readUTF();</span><br><span class="line">    <span class="keyword">int</span> age = dis.readInt();</span><br><span class="line"></span><br><span class="line">    System.out.println(name);</span><br><span class="line">    System.out.println(age);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (dis != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            dis.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注</strong>：<strong>读取数据的顺序要与当初写入文件时写入的顺序一致</strong></p>
<h2 id="对象流（处理流）"><a href="#对象流（处理流）" class="headerlink" title="对象流（处理流）"></a>对象流（处理流）</h2><p>用于读取和存储<strong>基本数据类型</strong>数据或<strong>对象</strong>的处理流。意味着可以将Java中对对象写入到数据中，也可以把对象从数据源中还原回来。</p>
<ul>
<li><strong>ObjectInputStream</strong>：序列化—-保存</li>
<li><strong>ObjectOutputStream</strong>：反序列化—-读取</li>
</ul>
<p><strong>注</strong>：不能序列化static和transient修饰的成员变量</p>
<h3 id="⭐对象序列化机制："><a href="#⭐对象序列化机制：" class="headerlink" title="⭐对象序列化机制："></a>⭐<strong>对象序列化机制</strong>：</h3><p>允许把内存中的Java对象转换为平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络结点，当其他程序获取了这种二进制流，就可以恢复成原来的Java对象。</p>
<p><strong>举例：对象的序列化和反序列化</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//序列化过程</span></span><br><span class="line">ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;oos.txt&quot;</span>));</span><br><span class="line">    oos.writeObject(<span class="keyword">new</span> String(<span class="string">&quot; i am a dog&quot;</span>));</span><br><span class="line">    oos.flush();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (oos != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            oos.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//反序列化过程</span></span><br><span class="line">ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;oos.txt&quot;</span>));</span><br><span class="line">    Object readObject = ois.readObject();</span><br><span class="line">    System.out.println(readObject);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (ois != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ois.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自定义类序列化："><a href="#自定义类序列化：" class="headerlink" title="自定义类序列化："></a><strong>自定义类序列化</strong>：</h3><p><strong>要求：</strong></p>
<ul>
<li>自定义类需要可序列化：<ul>
<li>需要实现接口Serializable</li>
<li>需要当前类提供一个全局常量：serialVersionUID</li>
</ul>
</li>
<li>除了当前Person类需要实现Serializable接口之外，还必须保证其内部所有属性也是可序列化的（默认基本数据类型都是可序列化的）</li>
</ul>
<p>Person自定义类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">422342L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>序列化反序列化测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//序列化过程</span></span><br><span class="line">ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;oos.txt&quot;</span>));</span><br><span class="line">    oos.writeObject(<span class="keyword">new</span> String(<span class="string">&quot; i am a dog&quot;</span>));</span><br><span class="line">    oos.flush();</span><br><span class="line">    oos.writeObject(<span class="keyword">new</span> Person(<span class="string">&quot;杨天宝&quot;</span>, <span class="number">32</span>));</span><br><span class="line">    oos.flush();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (oos != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            oos.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//反序列化过程</span></span><br><span class="line">ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;oos.txt&quot;</span>));</span><br><span class="line">    Object readObject = ois.readObject();</span><br><span class="line">    Object readObject1 = ois.readObject();</span><br><span class="line">    System.out.println(readObject);</span><br><span class="line">    System.out.println(readObject1);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (ois != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ois.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>serialVersionUID解释</strong>：</p>
<p>用来表明类的不同版本间的兼容性。即，其目的是以序列化对象进行版本控制，有关各版本反序列化时是否兼容。</p>
<p>如果类没有显式定义这个静态常量，它的值是Java运行时环境根据类的内部细节自动生成的。若类的实例变量做了修改，serialVersionUID可能会发生变化。会报错java.io.InvalidClassException。</p>
<p>针对上面序列化反序列话的例子，去掉显式定义serialVersionUID，先进行序列化，会根据类内的成员属性定义一个serialVersionUID，此时修改Person类中的属性如下，则再对已经序列化的实例化对象进行反序列化则会出现错误：java.io.InvalidClassException: IOStreamTest.Person; local class incompatible: stream classdesc serialVersionUID = 5870996536122812449, local class serialVersionUID = 422342，意味serialVersionUID不同，无法进行反序列化。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">422342L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="随机存取文件流（RandomAccessFile类）"><a href="#随机存取文件流（RandomAccessFile类）" class="headerlink" title="随机存取文件流（RandomAccessFile类）"></a>随机存取文件流（RandomAccessFile类）</h2><ul>
<li>直接继承于java.lang.Obejct，实现了DataInput，DataOutput，既可以作为输入流，又可以作为输出流；</li>
<li>创建RandomAccessFile类实例需要指定一个mode访问模式：<ul>
<li>r：只读</li>
<li>rw：读写</li>
<li>rwd：读写，同步文件内容的更新</li>
<li>rws：读写，同步文件内容和元数据的更新</li>
</ul>
</li>
</ul>
<p><strong>实现复制：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//既可以当输入流又可以当输出流</span></span><br><span class="line">RandomAccessFile raf1 = <span class="keyword">null</span>;</span><br><span class="line">RandomAccessFile raf2 = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//定义流</span></span><br><span class="line">    raf1 = <span class="keyword">new</span> RandomAccessFile(<span class="keyword">new</span> File(<span class="string">&quot;1.jpg&quot;</span>),<span class="string">&quot;r&quot;</span>);</span><br><span class="line">    raf2 = <span class="keyword">new</span> RandomAccessFile(<span class="keyword">new</span> File(<span class="string">&quot;5.jpg&quot;</span>),<span class="string">&quot;rw&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//复制操作</span></span><br><span class="line">    <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">while</span> ((len = raf1.read(buf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">        raf2.write(buf,<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//关闭资源通道</span></span><br><span class="line">    <span class="keyword">if</span> (raf2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            raf2.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (raf1 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            raf1.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>实现覆盖：</strong></p>
<p>如果RandomAccessFile作为输出流时，如果写出到的文件不存在，则在执行过程中自动创建；如果写出到的文件存在，则会对原有文件内容进行覆盖。（默认情况是从头开始覆盖，并非全部覆盖）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RandomAccessFile raf = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    raf = <span class="keyword">new</span> RandomAccessFile(<span class="keyword">new</span> File(<span class="string">&quot;test.txt&quot;</span>), <span class="string">&quot;rw&quot;</span>);</span><br><span class="line"></span><br><span class="line">    raf.write(<span class="string">&quot;1234567890&quot;</span>.getBytes());</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (raf != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            raf.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<p>原来test.txt文件中的内容：abcdefghijklmnopqrstuvwxyz</p>
<p>覆盖之后：1234567890klmnopqrstuvwxyz</p>
<p><strong>实现插入：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RandomAccessFile raf = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">    raf = <span class="keyword">new</span> RandomAccessFile(file, <span class="string">&quot;rw&quot;</span>);</span><br><span class="line"></span><br><span class="line">    raf.seek(<span class="number">5</span>);<span class="comment">//指针调到角标为5的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建StringBuilder用来存储上述角标位置之后的所有字节数据</span></span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder((<span class="keyword">int</span>)file.length());</span><br><span class="line">    <span class="keyword">byte</span>[] buff = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    <span class="keyword">while</span>((len = raf.read(buff)) != -<span class="number">1</span>)&#123;</span><br><span class="line">        sb.append(<span class="keyword">new</span> String(buff, <span class="number">0</span>, len));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    raf.seek(<span class="number">5</span>);<span class="comment">//指针调到角标为5的位置</span></span><br><span class="line">    <span class="comment">//覆盖写入&quot;1234567890&quot;</span></span><br><span class="line">    raf.write(<span class="string">&quot;1234567890&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (raf != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            raf.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行前test.txt文件内容：abcdepqrstuvwxyz</p>
<p>执行程序之后：abcde1234567890pqrstuvwxyz</p>
<h1 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h1><ul>
<li>NIO(New IO，Non-Blocking IO)是java1.4引入的一套新的IO API。与之前的IO有相同的作用和目的，但使用方法不同。NIO支持面向缓冲区的、基于通道的IO操作，IO是面向流的</li>
</ul>
<h1 id="NIO-2"><a href="#NIO-2" class="headerlink" title="NIO.2"></a>NIO.2</h1><ul>
<li>jdk7对NIO的扩展。</li>
</ul>
<h2 id="Path、Paths、Files核心API"><a href="#Path、Paths、Files核心API" class="headerlink" title="Path、Paths、Files核心API"></a>Path、Paths、Files核心API</h2><ul>
<li><p>早期Java提供File类来访问文件系统，但是功能有限，并且大多方法在出错时仅返回失败，不会童工异常信息。</p>
</li>
<li><p>NIO.2引入Path接口，可以看作是File类的升级版本，实际引用的资源也可以不存在。</p>
</li>
<li><p>Paths提供静态方法get()获取Path实例。</p>
</li>
<li><p>Files类用于操作文件或目录。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>IO流</category>
      </categories>
      <tags>
        <tag>IO流</tag>
      </tags>
  </entry>
  <entry>
    <title>集合框架</title>
    <url>/p/30172.html</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>为了方便对多个对象的操作，就要对对象进行存储。集合、数组都是对多个数据进行存储的结构，简称Java容器。使用Array存储对象存在一些弊端，而Java集合就像一种容器，可以动态地把多个对象的引用放入存储中。</p>
<a id="more"></a>

<p><strong>数组在内存存储方面的特点：</strong></p>
<ul>
<li>数组初始化之后，长度就固定了；</li>
<li>数组声明的类型，就决定了进行元素初始化时候的类型。</li>
</ul>
<p><strong>数组在存储数据方面的弊端：</strong></p>
<ul>
<li>数组初始化以后，长度无法修改，不便于扩展；</li>
<li>数组中提供的属性和方法少，不便于进行添加、删除、插入等操作，且效率不高，同时无法直接获取存储元素的个数；</li>
<li>数组存储的数据是有序的、可以重复的，即存储数据的特点单一。</li>
</ul>
<p><strong>数组和集合的区别：</strong></p>
<ul>
<li><strong>长度区别</strong>：数组固定；集合可变；</li>
<li><strong>内容区别</strong>：数组可以是基本数据类型，也可以是引用数据类型；集合只能是引用数据类型；</li>
<li><strong>元素内容</strong>：数组只能存储同一种类型；集合可以存储不同类型。</li>
</ul>
<p>Java集合可以分为Collection和Map两种体系:</p>
<p><strong>Collection</strong> 接口 对象的集合（单列集合）<br>├——-<strong>List</strong> 接口：元素按进入先后有序保存，可重复<br>│—————-├ <strong>ArrayList</strong> 接口实现类， 数组， 随机访问， 没有同步， 线程不安全<br>│—————-├ <strong>LinkedList</strong> 接口实现类， 链表， 插入删除， 没有同步， 线程不安全<br>│—————-└ <strong>Vector</strong> 接口实现类 数组， 同步， 线程安全<br>│ ———————-└ <strong>Stack</strong> 是Vector类的实现类<br>└——-<strong>Set</strong> 接口： 无序，不可重复，可做内部排序<br>├—————-└<strong>HashSet</strong> 底层数据结构有hash表、数组、链表<br>│————————└ <strong>LinkedHashSet</strong> 链表维护元素的插入次序<br>└ —————-<strong>TreeSet</strong> 底层实现为红黑树，元素排好序</p>
<p><strong>Map</strong> 接口 键值对的集合 （双列集合）<br>├———<strong>Hashtable</strong> 接口实现类， 同步， 线程安全<br>├———<strong>HashMap</strong> 接口实现类 ，没有同步， 线程不安全-<br>│—————–├ <strong>LinkedHashMap</strong> 双向链表和哈希表实现<br>│—————–└ <strong>WeakHashMap</strong><br>├ ——–<strong>TreeMap</strong> 红黑树对所有的key进行排序<br>└———<strong>IdentifyHashMap</strong></p>
<p><strong>Collection接口：</strong>单列数据，定义了存取一组对象的方法的集合</p>
<ul>
<li><strong>List：</strong>元素有序、可重复的集合   ——&gt;“动态数组”</li>
<li><strong>Set：</strong>元素无序、不可重复的集合   ——-&gt;高中学的“集合”</li>
</ul>
<p><strong>Map接口：</strong>双列数据，保存具有映射关系“key-value对”的集合  ——&gt;“函数”（两个不同的key可以对应同一个value，一个key不能对应多个value）</p>
<h1 id="Collection接口中方法的使用"><a href="#Collection接口中方法的使用" class="headerlink" title="Collection接口中方法的使用"></a>Collection接口中方法的使用</h1><ul>
<li><strong>add(E e)：</strong>将元素添加到集合中</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">System.out.println(<span class="string">&quot;-----------------add()测试-----------------&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;sd&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;qweqe&quot;</span>);</span><br><span class="line">coll.add(<span class="keyword">new</span> String(<span class="string">&quot;Marry&quot;</span>));</span><br><span class="line">coll.add(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;456&quot;</span>);<span class="comment">//自动装箱</span></span><br><span class="line">coll.add(<span class="keyword">new</span> Person(<span class="string">&quot;Tom&quot;</span>, <span class="number">3</span>));</span><br><span class="line">Person jerry = <span class="keyword">new</span> Person(<span class="string">&quot;Jerry&quot;</span>, <span class="number">2</span>);</span><br><span class="line">coll.add(jerry);</span><br><span class="line">coll.add(<span class="keyword">true</span>);</span><br><span class="line">System.out.println(coll);<span class="comment">//[aa, sd, qweqe, Marry, AA, 456, Person&#123;name=&#x27;Tom&#x27;, age=3&#125;, Person&#123;name=&#x27;Jerry&#x27;, age=2&#125;, true]</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>size()：</strong>返回此集合中的元素数</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;-----------------size()测试-----------------&quot;</span>);</span><br><span class="line">System.out.println(coll.size());<span class="comment">//9</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>addAll(Collection&lt;? extends E&gt; c)：</strong>将指定集合中的所有元素添加到此集合</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//addAll()</span></span><br><span class="line">System.out.println(<span class="string">&quot;-----------------addAll()测试-----------------&quot;</span>);</span><br><span class="line">Collection coll1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">coll1.add(<span class="string">&quot;qwe&quot;</span>);</span><br><span class="line">coll1.add(<span class="number">123</span>);</span><br><span class="line">coll.addAll(coll1);</span><br><span class="line">System.out.println(coll);<span class="comment">//[aa, sd, qweqe, Marry, AA, 456, Person&#123;name=&#x27;Tom&#x27;, age=3&#125;, Person&#123;name=&#x27;Jerry&#x27;, age=2&#125;, true, qwe, 123]</span></span><br><span class="line">System.out.println(coll.size());<span class="comment">//11</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>isEmpty()：</strong>如果此集合不包含元素，则返回 true</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//isEmpty()</span></span><br><span class="line">System.out.println(<span class="string">&quot;-----------------isEmpty()测试-----------------&quot;</span>);</span><br><span class="line">System.out.println(coll.isEmpty());<span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>clear()：</strong>清空集合元素</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//clear()</span></span><br><span class="line">coll.clear();</span><br><span class="line">System.out.println(coll.isEmpty());<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>contains(Object o)：</strong>如果此集合包含指定的元素，则返回 true</li>
</ul>
<p><strong>注</strong>：在判断的时候会调用obj对象所在的类的equals()方法</p>
<p>自定义Person类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        System.out.println(&quot;************调用Person的equals()方法**************&quot;);</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Person person = (Person) o;</span><br><span class="line">        <span class="keyword">return</span> age == person.age &amp;&amp;</span><br><span class="line">                Objects.equals(name, person.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    @Override</span></span><br><span class="line"><span class="comment">//    public int hashCode() &#123;</span></span><br><span class="line"><span class="comment">//        return Objects.hash(name, age);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line"><span class="comment">//        System.out.println(coll.size());</span></span><br><span class="line">        <span class="comment">//add()</span></span><br><span class="line">System.out.println(<span class="string">&quot;-----------------add()测试-----------------&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;sd&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;qweqe&quot;</span>);</span><br><span class="line">coll.add(<span class="keyword">new</span> String(<span class="string">&quot;Marry&quot;</span>));</span><br><span class="line">coll.add(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;456&quot;</span>);<span class="comment">//自动装箱</span></span><br><span class="line">coll.add(<span class="keyword">new</span> Person(<span class="string">&quot;Tom&quot;</span>, <span class="number">3</span>));</span><br><span class="line">Person jerry = <span class="keyword">new</span> Person(<span class="string">&quot;Jerry&quot;</span>, <span class="number">2</span>);</span><br><span class="line">coll.add(jerry);</span><br><span class="line">coll.add(<span class="keyword">true</span>);</span><br><span class="line">System.out.println(coll);</span><br><span class="line"><span class="comment">//contains()</span></span><br><span class="line">System.out.println(<span class="string">&quot;-----------------contains()测试-----------------&quot;</span>);</span><br><span class="line">System.out.println(coll.contains(<span class="string">&quot;aa&quot;</span>));<span class="comment">//true</span></span><br><span class="line">System.out.println(coll.contains(<span class="keyword">new</span> String(<span class="string">&quot;Marry&quot;</span>)));<span class="comment">//true</span></span><br><span class="line">System.out.println(coll.contains(jerry));<span class="comment">//true</span></span><br><span class="line">System.out.println(coll.contains(<span class="keyword">new</span> Person(<span class="string">&quot;Jerry&quot;</span>, <span class="number">2</span>)));<span class="comment">//</span></span><br></pre></td></tr></table></figure>
<p>重写了toString()方法之后，coll.contains(new Person(“Jerry”, 2))的结果为true，否则为false。</p>
<p><strong>所以<em>要求Collection接口的实现类的对象中添加数据obj时，要求obj所在类要重写equals()方法</em>。</strong></p>
<ul>
<li>**containsAll(Collection&lt;?&gt; c)**：如果此集合包含指定集合中的所有元素，则返回true</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//containsAll()</span></span><br><span class="line">System.out.println(<span class="string">&quot;-----------------containsAll()测试-----------------&quot;</span>);</span><br><span class="line">System.out.println(coll.containsAll(coll1));<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>remove(Object o)：</strong>从该集合中删除指定元素的单个实例（如果存在），不存在返回false</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">coll.add(<span class="string">&quot;sd&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;qweqe&quot;</span>);</span><br><span class="line">coll.add(<span class="keyword">new</span> Person(<span class="string">&quot;Tom&quot;</span>, <span class="number">3</span>));</span><br><span class="line">coll.add(<span class="keyword">true</span>);</span><br><span class="line">System.out.println(coll);<span class="comment">//[sd, qweqe, Person&#123;name=&#x27;Tom&#x27;, age=3&#125;, true]</span></span><br><span class="line">coll.remove(<span class="string">&quot;sd&quot;</span>);</span><br><span class="line">System.out.println(coll);<span class="comment">//[qweqe, Person&#123;name=&#x27;Tom&#x27;, age=3&#125;, true]</span></span><br><span class="line">coll.remove(<span class="keyword">new</span> Person(<span class="string">&quot;Tom&quot;</span>, <span class="number">3</span>));</span><br><span class="line">System.out.println(coll);<span class="comment">//[qweqe, true]</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>removeAll(Collection&lt;?&gt; c)：</strong>删除指定集合中包含的所有此集合的元素（<strong>差集</strong>操作）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//removeAll()</span></span><br><span class="line">Collection coll1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">coll1.add(<span class="string">&quot;qweqe&quot;</span>);</span><br><span class="line">coll1.add(<span class="string">&quot;dsaf&quot;</span>);</span><br><span class="line">coll1.add(<span class="keyword">new</span> Person(<span class="string">&quot;Tom&quot;</span>, <span class="number">3</span>));</span><br><span class="line">coll1.add(<span class="keyword">new</span> Person(<span class="string">&quot;Jerry&quot;</span>, <span class="number">3</span>));</span><br><span class="line">coll.removeAll(coll1);</span><br><span class="line">System.out.println(coll);<span class="comment">//[sd, true]</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>retainAll(Collection&lt;?&gt; c)：</strong>仅保留此集合中包含在指定集合中的元素（<strong>交集</strong>操作）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">coll.add(<span class="string">&quot;sd&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;qweqe&quot;</span>);</span><br><span class="line">coll.add(<span class="keyword">new</span> Person(<span class="string">&quot;Tom&quot;</span>, <span class="number">3</span>));</span><br><span class="line">coll.add(<span class="keyword">true</span>);</span><br><span class="line">System.out.println(coll);<span class="comment">//[sd, qweqe, Person&#123;name=&#x27;Tom&#x27;, age=3&#125;, true]</span></span><br><span class="line"><span class="comment">//retainAll()</span></span><br><span class="line">Collection coll1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">coll1.add(<span class="string">&quot;qweqe&quot;</span>);</span><br><span class="line">coll1.add(<span class="string">&quot;dsaf&quot;</span>);</span><br><span class="line">coll1.add(<span class="keyword">new</span> Person(<span class="string">&quot;Tom&quot;</span>, <span class="number">3</span>));</span><br><span class="line">coll1.add(<span class="keyword">new</span> Person(<span class="string">&quot;Jerry&quot;</span>, <span class="number">3</span>));</span><br><span class="line">coll.retainAll(coll1);</span><br><span class="line">System.out.println(coll);<span class="comment">//[qweqe, Person&#123;name=&#x27;Tom&#x27;, age=3&#125;]</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>equals()：</strong>判断当前集合和对比的集合是否相同。（注：有的有顺序有的没有）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">coll.add(<span class="string">&quot;sd&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;qweqe&quot;</span>);</span><br><span class="line">coll.add(<span class="keyword">new</span> Person(<span class="string">&quot;Tom&quot;</span>, <span class="number">3</span>));</span><br><span class="line">coll.add(<span class="keyword">true</span>);</span><br><span class="line">System.out.println(coll);<span class="comment">//[sd, qweqe, Person&#123;name=&#x27;Tom&#x27;, age=3&#125;, true]</span></span><br><span class="line">Collection coll1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">coll1.add(<span class="string">&quot;sd&quot;</span>);</span><br><span class="line">coll1.add(<span class="string">&quot;qweqe&quot;</span>);</span><br><span class="line">coll1.add(<span class="keyword">new</span> Person(<span class="string">&quot;Tom&quot;</span>, <span class="number">3</span>));</span><br><span class="line">coll1.add(<span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">boolean</span> equals = coll.equals(coll1);</span><br><span class="line">System.out.println(equals);<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>hashCode()：</strong>返回此集合的哈希码值</li>
<li><strong>toArray()：</strong>集合——-&gt;数组</li>
<li><strong>iterator()：</strong>返回此集合中的元素的迭代器</li>
</ul>
<h2 id="Iterator迭代器接口"><a href="#Iterator迭代器接口" class="headerlink" title="Iterator迭代器接口"></a>Iterator迭代器接口</h2><ul>
<li>Iterator对象成为迭代器（设计模式的一种），主要用于遍历Collection集合中的元素。</li>
<li>Collection子接口继承了Iterator父接口。</li>
<li>迭代器模式，就是为容器而生。</li>
<li>Iterator仅仅用于遍历集合，本身并不提供承装对象的能力。如果需要创建Iterator对象，必须有一个被迭代的集合。</li>
<li>集合对象每次调用iterator的时候都会得到一个全新的迭代器，默认指针都在集合的第一个元素之前。</li>
<li>内部有next()和hasNext()方法，搭配使用可以遍历集合中的全部元素。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">coll.add(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;sd&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;qweqe&quot;</span>);</span><br><span class="line">coll.add(<span class="keyword">new</span> String(<span class="string">&quot;Marry&quot;</span>));</span><br><span class="line">coll.add(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">coll.add(<span class="string">&quot;456&quot;</span>);<span class="comment">//自动装箱</span></span><br><span class="line">coll.add(<span class="keyword">new</span> Person(<span class="string">&quot;Tom&quot;</span>, <span class="number">3</span>));</span><br><span class="line">Person jerry = <span class="keyword">new</span> Person(<span class="string">&quot;Jerry&quot;</span>, <span class="number">2</span>);</span><br><span class="line">coll.add(jerry);</span><br><span class="line">coll.add(<span class="keyword">true</span>);</span><br><span class="line">System.out.println(coll);<span class="comment">//[aa, sd, qweqe, Marry, AA, 456, Person&#123;name=&#x27;Tom&#x27;, age=3&#125;, Person&#123;name=&#x27;Jerry&#x27;, age=2&#125;, true]</span></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">     System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注：</strong>在调用hasNext()的时候只是返回是否还有下一个元素，而调用next()的时候，<strong>指针下移并返回下一个元素</strong>。</p>
<h2 id="Iterator迭代器中的remove方法"><a href="#Iterator迭代器中的remove方法" class="headerlink" title="Iterator迭代器中的remove方法"></a>Iterator迭代器中的remove方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator iterator = coll.iterator();</span><br><span class="line">System.out.println(<span class="string">&quot;------------------删除之前------------------&quot;</span>);</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">     System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br><span class="line">Iterator iterator1 = coll.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator1.hasNext())&#123;</span><br><span class="line">     Object next = iterator1.next();</span><br><span class="line">     <span class="keyword">if</span> (<span class="string">&quot;aa&quot;</span>.equals(next))&#123;</span><br><span class="line">         iterator1.remove();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;------------------删除之后------------------&quot;</span>);</span><br><span class="line">Iterator iterator2 = coll.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator2.hasNext())&#123;</span><br><span class="line">      System.out.println(iterator2.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注：</strong></p>
<ul>
<li>Iterator可以删除集合的元素，但是是遍历过程中通过迭代器对象的remove方法，不是集合对象的remove方法；</li>
<li>如果还未调用next()或在上一次调用next方法之后已经调用了remove方法，再调用remove都会报IllegalStateException。（即指针还未指向第一个元素或者删除某个元素两次）</li>
</ul>
<h2 id="foreach循环遍历集合（jdk1-5）"><a href="#foreach循环遍历集合（jdk1-5）" class="headerlink" title="foreach循环遍历集合（jdk1.5）"></a>foreach循环遍历集合（jdk1.5）</h2><ul>
<li>for(集合元素的类型 局部变量 : 集合变量)</li>
<li>内部仍然调用了迭代器Iterator</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForEachTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Collection coll = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        coll.add(<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;sd&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;qweqe&quot;</span>);</span><br><span class="line">        coll.add(<span class="keyword">new</span> String(<span class="string">&quot;Marry&quot;</span>));</span><br><span class="line">        coll.add(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">        coll.add(<span class="string">&quot;456&quot;</span>);<span class="comment">//自动装箱</span></span><br><span class="line">        coll.add(<span class="keyword">new</span> Person(<span class="string">&quot;Tom&quot;</span>, <span class="number">3</span>));</span><br><span class="line">        Person jerry = <span class="keyword">new</span> Person(<span class="string">&quot;Jerry&quot;</span>, <span class="number">2</span>);</span><br><span class="line">        coll.add(jerry);</span><br><span class="line">        coll.add(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Object obj : coll)&#123;</span><br><span class="line">            System.out.println(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Collection的接口之一——List接口"><a href="#Collection的接口之一——List接口" class="headerlink" title="Collection的接口之一——List接口"></a>Collection的接口之一——List接口</h1><ul>
<li>LIst接口是Collection的子接口；</li>
<li>鉴于Java中数组的缺点，通常使用List替代数组；</li>
<li>List集合类中<strong>元素有序、且可重复</strong>；</li>
<li>Java API中List接口的实现类常用的有：ArrayList、LinkedList和Vector</li>
</ul>
<h2 id="ArrayList、LinkedList和Vector的异同"><a href="#ArrayList、LinkedList和Vector的异同" class="headerlink" title="ArrayList、LinkedList和Vector的异同"></a>ArrayList、LinkedList和Vector的异同</h2><p><strong>同：</strong></p>
<ul>
<li>三个类都实现了List接口，存储数据的特点相同：<strong>元素有序、且可重复</strong>；</li>
</ul>
<p><strong>异：</strong></p>
<ul>
<li>ArrayList是线程不安全的，但是效率高；Vector是线程安全的，但是效率低；</li>
<li>ArrayList和Vector底层都是使用Object[] elementData存储，LinkedList底层使用双向链表存储；</li>
</ul>
<h2 id="List接口的主要实现类—–ArrayList"><a href="#List接口的主要实现类—–ArrayList" class="headerlink" title="List接口的主要实现类—–ArrayList"></a>List接口的主要实现类—–ArrayList</h2><p>对于频繁查找操作，使用此类效率高。</p>
<p>ArrayList在jdk7和jdk8中不一样。</p>
<h3 id="ArrayList-—-jdk7"><a href="#ArrayList-—-jdk7" class="headerlink" title="ArrayList —- jdk7"></a>ArrayList —- jdk7</h3><ul>
<li>底层创建了长度为10的Object[]数组elementData</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList list = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br></pre></td></tr></table></figure>
<ul>
<li>按照顺序添加元素：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;def&quot;</span>);</span><br><span class="line">......</span><br><span class="line">list.add(<span class="number">123</span>);</span><br><span class="line">list.add(<span class="number">456</span>);</span><br></pre></td></tr></table></figure>
<p>如果当前添加导致底层elementData数组容量不够，则扩容。默认情况下，扩容为原来的1.5倍，同时需要将原有数组中的数据复制到新的数组中。</p>
<p><strong>注</strong>：如果大概确定数组长度，可以使用有参构造器，创造固定长度的数组。</p>
<h3 id="ArrayList-—-jdk8"><a href="#ArrayList-—-jdk8" class="headerlink" title="ArrayList —- jdk8"></a>ArrayList —- jdk8</h3><ul>
<li>底层Object[]数组elementData初始化为{}，并没有创建长度为10的数组</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList list = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br></pre></td></tr></table></figure>
<ul>
<li>第一次调用add()时，底层才创建了长度为10的数组，并将数据“abc”添加到elementData[0]。后续扩容操作和jdk7一样。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.add(<span class="string">&quot;abc&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>jdk7中ArrayList**</strong>的创建类似于单例模式中的<strong>饿汉式</strong>，<strong>jdk8中ArrayList</strong>的创建类似于单例模式中的<strong>懒汉式</strong>，延迟了数组的创建，<strong>节省了运行时内存</strong>。</p>
<h2 id="List接口的其次实现类—–LinkedList"><a href="#List接口的其次实现类—–LinkedList" class="headerlink" title="List接口的其次实现类—–LinkedList"></a>List接口的其次实现类—–LinkedList</h2><p>对于频繁的插入、删除操作，使用此类效率比ArrayList高。</p>
<ul>
<li>内部声明了Node类型的first和last属性，默认值为null</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">LinkedList linkedList = <span class="keyword">new</span> LinkedList();</span><br></pre></td></tr></table></figure>
<ul>
<li>将123封装到Node中，创建了Node对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">linkedList.add(<span class="number">123</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>双向链表</li>
</ul>
<h2 id="List接口的古老实现类—–Vector"><a href="#List接口的古老实现类—–Vector" class="headerlink" title="List接口的古老实现类—–Vector"></a>List接口的古老实现类—–Vector</h2><ul>
<li>jdk7和jdk8时创建对象时，底层都创建了长度为10得数组</li>
<li>扩容的时候，默认扩容为原来数组长度的2倍</li>
</ul>
<h2 id="List接口的常用方法"><a href="#List接口的常用方法" class="headerlink" title="List接口的常用方法"></a>List接口的常用方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList list = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line">list.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;def&quot;</span>);</span><br><span class="line">list.add(<span class="number">123</span>);</span><br><span class="line">list.add(<span class="number">456</span>);</span><br><span class="line">list.add(<span class="keyword">new</span> Person(<span class="string">&quot;Tom&quot;</span>, <span class="number">3</span>));</span><br><span class="line">System.out.println(list);<span class="comment">//[abc, def, 123, 456, Person&#123;name=&#x27;Tom&#x27;, age=3&#125;]</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>add(int index, E element)：</strong>将指定的元素插入此列表中的指定位置</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.add(<span class="number">1</span>,<span class="string">&quot;insert&quot;</span>);</span><br><span class="line">System.out.println(list);<span class="comment">//[abc, insert, def, 123, 456, Person&#123;name=&#x27;Tom&#x27;, age=3&#125;]</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>addAll(int index, Collection&lt;? extends E&gt; c)：</strong>将指定集合中的所有元素插入到此列表中的指定位置</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List list1 = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line">list.addAll(<span class="number">2</span>,list1);</span><br><span class="line">System.out.println(list);<span class="comment">//[abc, insert, 1, 2, 3, def, 123, 456, Person&#123;name=&#x27;Tom&#x27;, age=3&#125;]</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>get(int index)：</strong>返回此列表中指定位置的元素</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object o = list.get(<span class="number">0</span>);</span><br><span class="line">System.out.println(o);<span class="comment">//abc</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>indexOf(Object o)：</strong>返回此列表中指定元素的第一次出现的索引，如果此列表不包含元素，则返回-1</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> index = list.indexOf(<span class="number">123</span>);</span><br><span class="line">System.out.println(index);<span class="comment">//6</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>lastIndexOf(Object o)：</strong>返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> index1 = list.lastIndexOf(<span class="number">23</span>);</span><br><span class="line">System.out.println(index1);<span class="comment">//-1</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>remove(int index)：</strong>删除该列表中指定位置的元素（可选操作）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object remove = list.remove(<span class="number">6</span>);</span><br><span class="line">System.out.println(remove);<span class="comment">//123</span></span><br><span class="line">System.out.println(list);<span class="comment">//[abc, insert, 1, 2, 3, def, 456, Person&#123;name=&#x27;Tom&#x27;, age=3&#125;]</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>set(int index, E element)：</strong>用指定的元素替换此列表中指定位置的元素</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">list.set(<span class="number">0</span>,<span class="string">&quot;xyz&quot;</span>);</span><br><span class="line">System.out.println(list);<span class="comment">//[xyz, insert, 1, 2, 3, def, 456, Person&#123;name=&#x27;Tom&#x27;, age=3&#125;]</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>subList(int fromIndex, int toIndex)：</strong>返回此列表中指定的 fromIndex （含）和 toIndex之间的视图</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List subList = list.subList(<span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">System.out.println(subList);<span class="comment">//[1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<h2 id="总结List常用方法"><a href="#总结List常用方法" class="headerlink" title="总结List常用方法"></a>总结List常用方法</h2><ul>
<li><strong>增：</strong>add(Object o)</li>
<li>删：remove(int index)  /  remove(Object o)</li>
<li>改：set(int index, E element)</li>
<li>查：get(int index)</li>
<li>插：add(int index, E element)</li>
<li>长度：size()</li>
<li>遍历：①iterator迭代器②foreach循环③普通for循环</li>
</ul>
<p><strong>①iterator迭代器</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator iterator = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>②foreach循环</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (Object obj : list) &#123;</span><br><span class="line">    System.out.println(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>③普通for循环</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">    System.out.println(list.get(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Collection的接口之一——Set接口"><a href="#Collection的接口之一——Set接口" class="headerlink" title="Collection的接口之一——Set接口"></a>Collection的接口之一——Set接口</h1><ul>
<li>Set接口时Collection的子接口，Set接口中没有额外定义新的方法，使用的都是Collection接口中声明过的方法；</li>
<li>Set集合中的元素是<strong>无序的，不重复的</strong>；</li>
<li>对于存放在Set容器中的对象，对应的类一定要重写**equals()和hashCode(Object obj)**方法，以实现对象相等规则。</li>
<li>Set集合可以用来将列表中重复的元素筛除。</li>
<li>Java API中Set接口的实现类常用的有：HashSet、LinkedHashSet和TreeSet。</li>
</ul>
<h2 id="Set的无序性和不可重复性"><a href="#Set的无序性和不可重复性" class="headerlink" title="Set的无序性和不可重复性"></a>Set的无序性和不可重复性</h2><p><strong>Set的无序性</strong></p>
<p><strong>无序性不等于随机性</strong>。以HashSet为例，其在底层存储使用的是数组，存储的数据在底层数组中并非按照数组索引的顺序添加，而是根据数据的哈希值决定的。</p>
<p><strong>Set的不可重复性</strong></p>
<p>保证添加的元素按照equals()判断时，不能返回true，即：相同的元素只能添加一个。</p>
<h2 id="Set接口实现类添加元素的过程（以HashSet为例）"><a href="#Set接口实现类添加元素的过程（以HashSet为例）" class="headerlink" title="Set接口实现类添加元素的过程（以HashSet为例）"></a>Set接口实现类添加元素的过程（以HashSet为例）</h2><p>我们向HashSet中添加元素a，首先调用元素a所在类的hashCode()方法，计算元素a的哈希值，此哈希值接着通过某种算法计算出在HashSet底层<strong>数组</strong>中的存放位置（即，索引值），判断数组在此位置上是否已经有其他元素：</p>
<p>​    如果此位置上没有其他元素，则元素a添加成功；  —–&gt;情况1</p>
<p>​    如果此位置上有其他元素b（或者以链表形式存在多个元素），则比较元素a与元素b的hash值：</p>
<p>​        如果hash值不相同，则元素a添加成功；   —–&gt;情况2</p>
<p>​        如果hash值相同，进而需要调用元素a的equals()方法：</p>
<p>​            如果equals()返回true，则元素a添加失败；</p>
<p>​            如果equals()返回false，则元素a添加成功。   —–&gt;情况3</p>
<p><strong>说明</strong>：对于添加成功的情况2和情况3，元素a与已经存在指定索引位置上数据以<strong>链表</strong>的方式存储。jdk7中：元素a放到数组中，指向原来的元素；jdk8中：原来的元素放在数组中，指向元素a。（“七上八下”）</p>
<h2 id="重写hashCode-方法的基本原则"><a href="#重写hashCode-方法的基本原则" class="headerlink" title="重写hashCode()方法的基本原则"></a>重写hashCode()方法的基本原则</h2><ul>
<li>在程序运行时，同一个对象多次调用hashCode()应该返回相同的值；</li>
<li>当两个对象的equals()方法比较返回true时，hashCode()计算出的hash值也应该相等；</li>
<li>对象中用作equals()方法比较的Field，都应该用来计算hashCode值。</li>
</ul>
<h2 id="Set接口的主要实现类——HashSet"><a href="#Set接口的主要实现类——HashSet" class="headerlink" title="Set接口的主要实现类——HashSet"></a>Set接口的主要实现类——HashSet</h2><ul>
<li><p>线程不安全的；</p>
</li>
<li><p>可以存储null值；</p>
</li>
<li><p>不能保证元素的排列顺序；</p>
</li>
<li><p>HashSet集合判断两个元素是否相等的标准：两个对象通过HashCode()方法比较相等，并且两个对象的equals()方法返回值也相等；</p>
</li>
<li><p>对于存放在Set容器中的对象，<strong>对应的类一定要重写equals()和hashCode(Object obj)方法</strong>，以实现对象相等规则。即<strong>相等的对象必须要有相等的散列码。</strong></p>
</li>
<li><p>HashSet的内部实现是HashMap</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure>
<h2 id="Set接口的实现类—–LinkedHashSet"><a href="#Set接口的实现类—–LinkedHashSet" class="headerlink" title="Set接口的实现类—–LinkedHashSet"></a>Set接口的实现类—–LinkedHashSet</h2></li>
<li><p>作为HashSet的子类；</p>
</li>
<li><p>在添加数据的同时，每个数据还维护了两个引用，记录此数据前一个数据和后一个数据。遍历内部数据时，可以按照添加的顺序遍历。</p>
</li>
<li><p>对于频繁的遍历操作，LinkedHashSet效率高于HashSet。</p>
</li>
</ul>
<h2 id="Set接口的实现类—–TreeSet"><a href="#Set接口的实现类—–TreeSet" class="headerlink" title="Set接口的实现类—–TreeSet"></a>Set接口的实现类—–TreeSet</h2><ul>
<li>可以按照添加元素的指定属性进行排序。</li>
<li>向TreeSet中添加数据，要求是相同类的对象，不能添加不同类的对象，否则会报错ClassCastException。</li>
<li>有两种排序方式：自然排序和定制排序。</li>
<li>TreeSet的底层是红黑树。</li>
<li>自然排序中，比较两个对象是否相同的标准是compareTo()返回0，不再是equals()。</li>
<li>定制排序中，比较两个对象是否相同的标准是compare()返回0，不再是equals()。</li>
</ul>
<p><strong>自然排序：</strong></p>
<p>Person类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        System.out.println(&quot;************调用Person的equals()方法**************&quot;);</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        Person person = (Person) o;</span><br><span class="line">        <span class="keyword">return</span> age == person.age &amp;&amp;</span><br><span class="line">                Objects.equals(name, person.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Person)&#123;</span><br><span class="line">            Person person = (Person)o;</span><br><span class="line"><span class="comment">//            return this.name.compareTo(person.name);</span></span><br><span class="line">            <span class="keyword">int</span> compare = <span class="keyword">this</span>.name.compareTo(person.name);</span><br><span class="line">            <span class="keyword">if</span> (compare != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> compare;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> Integer.compare(<span class="keyword">this</span>.age,person.age);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;输入类型不一致&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要实现排序，Person类应该实现Comparable接口，并重写其中方法compareTo()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeSet treeSet = <span class="keyword">new</span> TreeSet();</span><br><span class="line">treeSet.add(<span class="keyword">new</span> Person(<span class="string">&quot;Jerry&quot;</span>,<span class="number">2</span>));</span><br><span class="line">treeSet.add(<span class="keyword">new</span> Person(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>));</span><br><span class="line">treeSet.add(<span class="keyword">new</span> Person(<span class="string">&quot;Mary&quot;</span>,<span class="number">23</span>));</span><br><span class="line">treeSet.add(<span class="keyword">new</span> Person(<span class="string">&quot;Jim&quot;</span>,<span class="number">4</span>));</span><br><span class="line">treeSet.add(<span class="keyword">new</span> Person(<span class="string">&quot;Mike&quot;</span>,<span class="number">15</span>));</span><br><span class="line">treeSet.add(<span class="keyword">new</span> Person(<span class="string">&quot;Mary&quot;</span>,<span class="number">53</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Iterator iterator = treeSet.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person&#123;name=<span class="string">&#x27;Jerry&#x27;</span>, age=<span class="number">2</span>&#125;</span><br><span class="line">Person&#123;name=<span class="string">&#x27;Jim&#x27;</span>, age=<span class="number">4</span>&#125;</span><br><span class="line">Person&#123;name=<span class="string">&#x27;Mary&#x27;</span>, age=<span class="number">23</span>&#125;</span><br><span class="line">Person&#123;name=<span class="string">&#x27;Mary&#x27;</span>, age=<span class="number">53</span>&#125;</span><br><span class="line">Person&#123;name=<span class="string">&#x27;Mike&#x27;</span>, age=<span class="number">15</span>&#125;</span><br><span class="line">Person&#123;name=<span class="string">&#x27;Tom&#x27;</span>, age=<span class="number">12</span>&#125;</span><br></pre></td></tr></table></figure>
<p><strong>定制排序：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Comparator comparator = <span class="keyword">new</span> Comparator&lt;Person&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person o1, Person o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Integer.compare(o1.getAge(),o2.getAge()) != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.compare(o1.getAge(),o2.getAge());</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> o1.getName().compareTo(o2.getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">TreeSet treeSet = <span class="keyword">new</span> TreeSet(comparator);</span><br><span class="line">treeSet.add(<span class="keyword">new</span> Person(<span class="string">&quot;Jerry&quot;</span>,<span class="number">2</span>));</span><br><span class="line">treeSet.add(<span class="keyword">new</span> Person(<span class="string">&quot;Tom&quot;</span>,<span class="number">12</span>));</span><br><span class="line">treeSet.add(<span class="keyword">new</span> Person(<span class="string">&quot;Mary&quot;</span>,<span class="number">23</span>));</span><br><span class="line">treeSet.add(<span class="keyword">new</span> Person(<span class="string">&quot;Jim&quot;</span>,<span class="number">4</span>));</span><br><span class="line">treeSet.add(<span class="keyword">new</span> Person(<span class="string">&quot;Mike&quot;</span>,<span class="number">15</span>));</span><br><span class="line">treeSet.add(<span class="keyword">new</span> Person(<span class="string">&quot;Mary&quot;</span>,<span class="number">53</span>));</span><br><span class="line">treeSet.add(<span class="keyword">new</span> Person(<span class="string">&quot;Lily&quot;</span>,<span class="number">12</span>));</span><br><span class="line"></span><br><span class="line">Iterator iterator = treeSet.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person&#123;name=<span class="string">&#x27;Jerry&#x27;</span>, age=<span class="number">2</span>&#125;</span><br><span class="line">Person&#123;name=<span class="string">&#x27;Jim&#x27;</span>, age=<span class="number">4</span>&#125;</span><br><span class="line">Person&#123;name=<span class="string">&#x27;Lily&#x27;</span>, age=<span class="number">12</span>&#125;</span><br><span class="line">Person&#123;name=<span class="string">&#x27;Tom&#x27;</span>, age=<span class="number">12</span>&#125;</span><br><span class="line">Person&#123;name=<span class="string">&#x27;Mike&#x27;</span>, age=<span class="number">15</span>&#125;</span><br><span class="line">Person&#123;name=<span class="string">&#x27;Mary&#x27;</span>, age=<span class="number">23</span>&#125;</span><br><span class="line">Person&#123;name=<span class="string">&#x27;Mary&#x27;</span>, age=<span class="number">53</span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="HashSet例题"><a href="#HashSet例题" class="headerlink" title="HashSet例题"></a>HashSet例题</h2><p>User类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&quot;</span> + id +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        User user = (User) o;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (id != user.id) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> name != <span class="keyword">null</span> ? name.equals(user.name) : user.name == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = id;</span><br><span class="line">        result = <span class="number">31</span> * result + (name != <span class="keyword">null</span> ? name.hashCode() : <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">exer2</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        HashSet set = <span class="keyword">new</span> HashSet();</span><br><span class="line">        User u1 = <span class="keyword">new</span> User(<span class="number">1001</span>,<span class="string">&quot;aa&quot;</span>);</span><br><span class="line">        User u2 = <span class="keyword">new</span> User(<span class="number">1002</span>,<span class="string">&quot;bb&quot;</span>);</span><br><span class="line"></span><br><span class="line">        set.add(u1);</span><br><span class="line">        set.add(u2);</span><br><span class="line"></span><br><span class="line">        u1.setName(<span class="string">&quot;cc&quot;</span>);</span><br><span class="line">        set.remove(u1);</span><br><span class="line">        System.out.println(set);<span class="comment">//---------&gt;①[User&#123;id=1002, name=&#x27;bb&#x27;&#125;, User&#123;id=1001, name=&#x27;cc&#x27;&#125;]</span></span><br><span class="line"></span><br><span class="line">        set.add(<span class="keyword">new</span> User(<span class="number">1001</span>,<span class="string">&quot;cc&quot;</span>));</span><br><span class="line">        System.out.println(set);<span class="comment">//---------&gt;②[User&#123;id=1002, name=&#x27;bb&#x27;&#125;, User&#123;id=1001, name=&#x27;cc&#x27;&#125;, User&#123;id=1001, name=&#x27;cc&#x27;&#125;]</span></span><br><span class="line"></span><br><span class="line">        set.add(<span class="keyword">new</span> User(<span class="number">1001</span>,<span class="string">&quot;aa&quot;</span>));</span><br><span class="line">        System.out.println(set);<span class="comment">//---------&gt;③[User&#123;id=1002, name=&#x27;bb&#x27;&#125;, User&#123;id=1001, name=&#x27;cc&#x27;&#125;, User&#123;id=1001, name=&#x27;cc&#x27;&#125;, User&#123;id=1001, name=&#x27;aa&#x27;&#125;]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>结果分析：</strong></p>
<p>①set集合中通过计算哈希值已经添加了u1和u2，将u1中的name属性赋值为cc，此时u1所在的地址还是由u1原来的属性（1001，“aa”）计算得来的。当reomve的时候，首先要判断是否存在这个元素，判断是根据u1新的属性（1001，“cc”）进行的，此时集合中不存在这样一个地址，所以删除失败。</p>
<p>②当添加新的元素时，按照新元素的属性（1001，“cc”）计算地址值，此时在set集合中不存在这样的地址，所以可以添加成功。</p>
<p>③添加新的元素，按照新元素的属性（1001，“aa”）计算出地址值，发现该地址值上已经存在一个元素，进行使用equals()进行比较，发现和以存在的元素u1（1001，“cc”）中属性有不一致的，所以以链表的形式添加成功。</p>
<h1 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h1><p><strong>Map</strong> 接口 键值对的集合 （双列集合） key-value对<br>├———<strong>Hashtable</strong> 接口实现类， 同步， 线程安全，不能存储null的key和value<br>├———<strong>HashMap</strong> 接口实现类 ，没有同步， 线程不安全，可以存储null的key和value<br>│—————–├ <strong>LinkedHashMap</strong> 双向链表和哈希表实现，频繁遍历操作<br>│—————–└ <strong>WeakHashMap</strong><br>├ ——–<strong>TreeMap</strong> 红黑树对所有的key进行排序，实现排序遍历，此时考虑key的自然排序和定制排序<br>└———<strong>IdentifyHashMap</strong></p>
<p>Map和Collection是一个并列的接口。</p>
<h2 id="Map结构理解"><a href="#Map结构理解" class="headerlink" title="Map结构理解"></a>Map结构理解</h2><p><strong>Map中的key：</strong>无序的，不可重复的，使用Set存储所有key —-&gt;key所在的类要重写equals()和hashCode()方法（以hashMap为例）</p>
<p><strong>Map中的value</strong>：无序的、可重复的，使用Collection存储所有的value —-&gt;value所在的类要重写equals()方法</p>
<p>一个键值对：key-value构成了一个Entry对象；</p>
<p><strong>Map中的Entry</strong>：无序的，不可重复的，使用Set存储所有的entry。</p>
<h2 id="⭐Map的主要实现类—–HashMap（jdk7）"><a href="#⭐Map的主要实现类—–HashMap（jdk7）" class="headerlink" title="⭐Map的主要实现类—–HashMap（jdk7）"></a>⭐Map的主要实现类—–HashMap（jdk7）</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map map = <span class="keyword">new</span> HashMap();</span><br></pre></td></tr></table></figure>
<p>在实例化以后，底层创建了长度是16的一维数组Entry[] table；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">...可能已经执行过多次put...</span><br><span class="line">map.put(key1,value1);</span><br></pre></td></tr></table></figure>
<p>首先，调用key1所在类的hashCode()计算key1哈希值，此哈希值经过某种算法计算以后，得到Entry数组中的存放位置。</p>
<p>如果此位置上的数据为空，此时key1-value1添加成功。  —–&gt;情况1</p>
<p>如果此位置上的数据不为空（此位置上存在一个或者多个数据（链表形式）），比较key1和已经存在的一个或多个数据的hash值：</p>
<p>​    如果key1的哈希值与已经存在的数据的哈希值都不相同，此时key1-value1添加成功。  —–&gt;情况2</p>
<p>​    如果key1的哈希值与已经存在的某一个数据（key2，value2）的哈希值相同，调用key1的equals(key2)方法进行比较：</p>
<p>​        如果返回值为false，此时key1-value1添加成功。  —–&gt;情况3</p>
<p>​        如果返回值为true，使用value1替换相同key的value2值。</p>
<p><strong>说明：</strong>对于添加成功的情况2和情况3，此时key1-value1和原来的数据以链表的形式存储。</p>
<p>在不断的添加过程中，会涉及到扩容问题，当添加后的容量超过设定的阈值，且当前索引位置不为空时，默认的扩容方式：扩容为原来容量的2倍，并将原来的数据复制过来。</p>
<h2 id="⭐Map的主要实现类之一—–HashMap（jdk8）"><a href="#⭐Map的主要实现类之一—–HashMap（jdk8）" class="headerlink" title="⭐Map的主要实现类之一—–HashMap（jdk8）"></a>⭐Map的主要实现类之一—–HashMap（jdk8）</h2><p><strong>jdk8相较于jdk7，HashMap在底层实现方面的不同：</strong></p>
<ol>
<li>jdk8中底层的数组不是Entry[]，是**Node[]**；</li>
<li>**new HashMap()**：底层没有创建一个长度为16的数组；</li>
<li><strong>首次调用put()方法</strong>时，底层创建长度为16的Node数组；</li>
<li>jdk7底层结构只有数组+链表，jdk底层结构有<strong>数组+链表+红黑树</strong>。<strong>当数组的某一个索引位置上的元素以链表形式存在的数据个数&gt;8且当前数组长度&gt;64时，此时此索引位置上的所有数据改为使用红黑树存储。</strong></li>
</ol>
<h2 id="⭐HashMap源码详读（jdk8）"><a href="#⭐HashMap源码详读（jdk8）" class="headerlink" title="⭐HashMap源码详读（jdk8）"></a>⭐HashMap源码详读（jdk8）</h2><h3 id="属性分析"><a href="#属性分析" class="headerlink" title="属性分析"></a><strong>属性分析</strong></h3><p><strong>初始容量</strong>：默认16</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br></pre></td></tr></table></figure>
<p><strong>最大容量</strong>：默认1 &lt;&lt; 30</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br></pre></td></tr></table></figure>
<p><strong>负载因子</strong>：默认0.75，当容器使用率达到75%的时候就要扩容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure>
<p><strong>红黑树阈值</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br></pre></td></tr></table></figure>
<p>只有满足当前位置的链表长度超过8，且整个数组长度超过64的时候，才将当前位置的链表转化为红黑树存储。</p>
<p><strong>问：为什么要设置负载因子？而不像ArrayList那样当当前数组满了之后再进行扩容？</strong></p>
<p><strong>答：</strong>ArrayList容器中每个位置只存储一个元素，且是按照顺序排列，而HashMap中每个容器中可能存储不止一个元素，因为在HashMap中数据可以以链表或红黑树的形式不断叠加存储，很难出现真正满了的情况。所以要使用负载因子设置一个阈值，如果整个容器中所存储的元素超过该阈值，就进行扩容，尽量减少链表和红黑树的形成。</p>
<p><strong>问：为什么要引入红黑树？</strong></p>
<p><strong>答：</strong>解决过长链表效率低的问题。通俗地讲，我们在往数组里存储数据的时候，要首先判断该数据通过哈希值计算出的位置上是否存在数据，是否存在相同的数据，如果该位置上已经有很多的数据以链表的形式存储，那么需要将该数据与链表上的数据一一进行对比，效率极低。</p>
<p><strong>问：为什么要设置MIN_TREEIFY_CAPACITY？</strong></p>
<p><strong>答：</strong>当数组长度很短的时候，出现了超过长度为8的链表，这时更需要的是扩容，扩容之后可能就没有这么长的链表存在了。同时，即使是使用红黑树比链表查找对比效率高，也没有直接存储在数组里查找效率高。</p>
<p><strong>问：初始容量是16，为什么是2的指数次幂？</strong></p>
<p><strong>答：</strong>因为要保证key的值尽量不重复，key的hashcode值的高低16位做异或运算（得出hash值）再与数组的长度-1的二进制做与运算，得出index。<br>如果数组长度的二进制是0的话，key的hashcode值的每一位无论是1还是0做与运算都是0，这样重复的概率就变大，因此必须都是1。而<br>1111+1=1 0000 就是2^4<br>1 1111+1=10 0000 2^5，结果都是2的N次方<br>2^N - 1可以使二进制每位都是1</p>
<p><strong>问：加载因子为什么是 0.75f ？</strong></p>
<p><strong>答：</strong>默认加载因子 0.75 在时间和空间开销上给出了一个较好的折衷。<br>如果加载因子过大，空间开销少了，但会导致查找元素效率低；而过小则会导致空间开销大，数组利用率低，分布稀疏。</p>
<p>具体的数值是通过牛顿二项式定理，求得了极限值（key接近无限大时） ：log2 ≈ 0.693 （这个是在Stack Overflow找到的答案）</p>
<h3 id="构造方法分析"><a href="#构造方法分析" class="headerlink" title="构造方法分析"></a><strong>构造方法分析</strong></h3><p><strong>构造方法一：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial</span></span><br><span class="line"><span class="comment"> * capacity and load factor.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  initialCapacity the initial capacity</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  loadFactor      the load factor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative</span></span><br><span class="line"><span class="comment"> *         or the load factor is nonpositive</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>构造方法二：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>构造方法三：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>构造方法四：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructs a new &lt;tt&gt;HashMap&lt;/tt&gt; with the same mappings as the</span></span><br><span class="line"><span class="comment"> * specified &lt;tt&gt;Map&lt;/tt&gt;.  The &lt;tt&gt;HashMap&lt;/tt&gt; is created with</span></span><br><span class="line"><span class="comment"> * default load factor (0.75) and an initial capacity sufficient to</span></span><br><span class="line"><span class="comment"> * hold the mappings in the specified &lt;tt&gt;Map&lt;/tt&gt;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   m the map whose mappings are to be placed in this map</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>  NullPointerException if the specified map is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造方法实际上是对初始容量和负载因子进行设置。上面4个构造方法，最常用的是构造方法3，该构造方法仅仅设置了负载因子为默认值0.75。构造方法2调用了构造方法1。构造方法4是将另一个Map中的映射复制一份到自己的存储结构中来，不常用。</p>
<p>针对构造方法1，进行详细的解释：</p>
<p>​    如果初始容量&lt;0，抛出异常；</p>
<p>​    如果初始容量&gt;最大容量，则将初始容量设置为最大容量；</p>
<p>​    如果负载因子&lt;0或者不是一个数字的话，抛出异常；</p>
<p>​    将传入的负载因子赋值给属性loadFactor；</p>
<p>​    计算阈值threshold：tableSizeFor()方法会将传入的容量设置为大于并最接近的2^N。</p>
<p>tableSizeFor()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="put-方法"><a href="#put-方法" class="headerlink" title="put()方法"></a>put()方法</h3><p>在调用构造器的时候并没有初始化数组，<strong>真正数组初始化是在第一次调用put()方法时</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="hash-方法"><a href="#hash-方法" class="headerlink" title="hash()方法"></a>hash()方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过计算key的hashcode，再将key的hashcode（散列码）值的高低16位做异或运算。</p>
<p><strong>问：为什么不直接使用hashcode的值？</strong></p>
<p><strong>答：</strong>可以增加hash的复杂度。当我们重写hashCode()方法的时候，可能会写出分布性不佳的hashCode()方法，进而导致hash的冲突率比较高。通过移位和异或运算，可以让hash变得更为复杂，进而影响hash的分布性。</p>
<h4 id="putVal-方法"><a href="#putVal-方法" class="headerlink" title="putVal()方法"></a>putVal()方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">//判断当前数组是否已经初始化</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//若未初始化，调用resize()方法进行初始化（默认长度为6）</span></span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">//(n-1)&amp;hash确定元素放在哪个桶里</span></span><br><span class="line">    <span class="comment">//如果桶是空的</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//新生成的结点放入桶中（此时结点是放在数组中）</span></span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//如果桶中不为空</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">//如果与该桶中第一个结点的key的hash值相等，key也相等</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="comment">//将第一个元素赋值给e，用e来记录</span></span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">//如果与该桶中第一个结点不相等，且结点为红黑树结点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">//放入树中</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">//如果与该桶中第一个结点不相等，且结点为链表结点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//遍历链表</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">//如果下一个元素为空，即链表的尾部</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//在链表的尾部插入新的结点</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">//如果结点数量达到阈值8</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        <span class="comment">//尝试转换为红黑树</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="comment">//跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果下一个元素不为空，遍历判断链表中结点的key与插入元素的key是否相等</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="comment">//相等，跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//e有记录，表示在桶中找到的元素的key值、hash值与插入元素相等的结点</span></span><br><span class="line">        <span class="comment">//即，如果桶中有存在key相同的元素</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            <span class="comment">//记录桶中那个元素的value值</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="comment">// onlyIfAbsent if true, don&#x27;t change existing value</span></span><br><span class="line">            <span class="comment">//如果onlyIfAbsent为false，或者记录的桶中那个元素的value为null</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">//用新的value替换旧的value</span></span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="comment">// 访问后回调，将元素添加到链表的最后</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="comment">// 返回旧值</span></span><br><span class="line">            <span class="comment">// map.put(1, &quot;Orcas&quot;);</span></span><br><span class="line">            <span class="comment">// String oldVal = map.put(1, &quot;Fish&quot;);</span></span><br><span class="line">            <span class="comment">// =&gt; Orcas</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 每次put一个元素++size,当实际大小大于阈值则扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="resize-方法"><a href="#resize-方法" class="headerlink" title="resize()方法"></a>resize()方法</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;<span class="comment">// table如果为空，oldCap长度设置为0</span></span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;<span class="comment">//如果table是空的，那么threshold=0</span></span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//如果旧数组中有元素，说明已经初始化过，调用resize()进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果旧数组的容量超过了最大容量2^30</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            <span class="comment">//将阈值设置为Integer的最大值</span></span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="comment">//但是数据大小不变</span></span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//旧数组双倍扩容后小于最大容量 并且 旧数组大于默认的初始容量16</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="comment">// 将阈值threshold*2得到新的阈值</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 旧阈值=threshold大于0</span></span><br><span class="line">    <span class="comment">// 说明使用的构造方法是HashMap(int initialCapacity, float loadFactor) </span></span><br><span class="line">    <span class="comment">// 该方法中 this.threshold = tableSizeFor(initialCapacity);</span></span><br><span class="line">    <span class="comment">// tableSizeFor方法返回的是数组的容量（2^N），例如initialCapacity是1000，那么得到的threshold就是1024，这里threshold就等于数组的容量</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        <span class="comment">// 容量设置为阈值threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="comment">// 阈值为初始化时的0，oldCap为空，即创建数组时无参，调用resize()是为了初始化为默认值</span></span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        <span class="comment">// 将新的长度设置为默认的初始化长度，即16</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        <span class="comment">// 负载因子0.75*数组长度16=12 新阈值为12</span></span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果新阈值为0，根据负载因子设置新阈值</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;<span class="comment">// 扩容的阈值（可能是以上几种情况之一得到的）</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];<span class="comment">// 创建一个长度为newCap的新的Node数组</span></span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="comment">// 如果旧的数组中有数据，则将数组复制到新的数组中</span></span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 循环遍历旧数组，将有元素的节点进行复制</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="comment">// 旧数组有元素的节点</span></span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 数组</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">// 重新计算hash值确定元素的位置</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">//红黑树</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">// 将原本的二叉树结构拆分组成新的红黑树</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="comment">//链表</span></span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    <span class="comment">// jdk1.8中 旧链表迁移新链表 链表元素相对位置没有变化; 实际是对对象的内存地址进行操作 </span></span><br><span class="line">                    <span class="comment">// jdk1.7中 旧链表迁移新链表 如果在新表的数组索引位置相同，则链表元素会倒置</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="Map的实现类之二—–LinkedHashMap"><a href="#Map的实现类之二—–LinkedHashMap" class="headerlink" title="Map的实现类之二—–LinkedHashMap"></a>Map的实现类之二—–LinkedHashMap</h2><ul>
<li>LinkedHashMap能够记录添加的元素的先后顺序</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; before, after;</span><br><span class="line">    Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Map中的常用方法"><a href="#Map中的常用方法" class="headerlink" title="Map中的常用方法"></a>Map中的常用方法</h2><ul>
<li>**put(K key, V value)**：将指定的值与该映射中的指定键相关联</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">map.put(<span class="string">&quot;aa&quot;</span>,<span class="number">123</span>);<span class="comment">//添加</span></span><br><span class="line">map.put(<span class="string">&quot;bb&quot;</span>,<span class="number">324</span>);</span><br><span class="line">map.put(<span class="string">&quot;cc&quot;</span>,<span class="number">457</span>);</span><br><span class="line">map.put(<span class="string">&quot;aa&quot;</span>,<span class="number">877</span>);<span class="comment">//修改</span></span><br><span class="line">System.out.println(map);<span class="comment">//&#123;aa=877, bb=324, cc=457&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>putAll(Map&lt;? extends K,? extends V&gt; m)：</strong>将指定地图的所有映射复制到此映射</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map map1 = <span class="keyword">new</span> HashMap();</span><br><span class="line">map1.put(<span class="string">&quot;jjw&quot;</span>,<span class="number">38</span>);</span><br><span class="line">map1.put(<span class="string">&quot;xkj&quot;</span>,<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">map.putAll(map1);</span><br><span class="line">System.out.println(<span class="string">&quot;##########putAll()##########&quot;</span>);</span><br><span class="line">System.out.println(map);<span class="comment">//&#123;aa=877, bb=324, cc=457, jjw=38, xkj=30&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>remove(Object key)：</strong>如果存在，从该地图中删除一个键的映射</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object bb = map.remove(<span class="string">&quot;bb&quot;</span>);</span><br><span class="line">System.out.println(bb);<span class="comment">//324</span></span><br><span class="line">System.out.println(map);<span class="comment">//&#123;aa=877, cc=457, jjw=38, xkj=30&#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object abb = map.remove(<span class="string">&quot;abb&quot;</span>);</span><br><span class="line">System.out.println(abb);<span class="comment">//null</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>clear()：</strong>从该地图中删除所有的映射，与map=null不同</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">map.clear();</span><br><span class="line">System.out.println(map.isEmpty());<span class="comment">//true</span></span><br><span class="line">System.out.println(map);<span class="comment">//&#123;&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>get(Object key)：</strong>返回到指定键所映射的值，或 <code>null</code>如果此映射包含该键的映射</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(map.get(<span class="string">&quot;jjw&quot;</span>));<span class="comment">//38</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>containsKey(Object key)：</strong>如果此映射包含指定键的映射，则返回 true </li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(map.containsKey(<span class="string">&quot;jjw&quot;</span>));<span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>containsValue(Object value)：</strong>如果此地图将一个或多个键映射到指定的值，则返回 true</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(map.containsValue(<span class="number">324</span>));</span><br></pre></td></tr></table></figure>
<ul>
<li><p><strong>equals(Object o)：</strong>将指定的对象与此映射进行比较以获得相等性</p>
</li>
<li><p><strong>isEmpty()：</strong>如果此地图不包含键值映射，则返回 true</p>
</li>
<li><p><strong>size()：</strong>返回此地图中键值映射的数量</p>
</li>
</ul>
<h2 id="Map遍历"><a href="#Map遍历" class="headerlink" title="Map遍历"></a>Map遍历</h2><p><img src="/p/Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210107195746697.png" alt="image-20210107195746697"></p>
<ul>
<li>**Set keySet():**返回所有key构成的Set集合</li>
<li>**Collection values():**返回所有value构成的Collection集合</li>
<li>**Set entrySet():**返回所有key-value对构成的Set集合</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">    map.put(<span class="string">&quot;aa&quot;</span>,<span class="number">123</span>);</span><br><span class="line">    map.put(<span class="number">45</span>,<span class="number">678</span>);</span><br><span class="line">    map.put(<span class="string">&quot;bb&quot;</span>,<span class="number">910</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//所有key构成的Set集合</span></span><br><span class="line">    Set keySet = map.keySet();</span><br><span class="line">    Iterator iterator = keySet.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//所有value构成的Collection集合</span></span><br><span class="line">    Collection values = map.values();</span><br><span class="line">    <span class="keyword">for</span> (Object obj : values) &#123;</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//所有key-value对构成的Set集合，entrySet集合中的元素都是entry</span></span><br><span class="line">    Set entrySet = map.entrySet();</span><br><span class="line">    iterator = entrySet.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">aa</span><br><span class="line">bb</span><br><span class="line">45</span><br><span class="line">123</span><br><span class="line">910</span><br><span class="line">678</span><br><span class="line">aa&#x3D;123</span><br><span class="line">bb&#x3D;910</span><br><span class="line">45&#x3D;678</span><br></pre></td></tr></table></figure>
<h2 id="Map的实现类之三—–TreeMap"><a href="#Map的实现类之三—–TreeMap" class="headerlink" title="Map的实现类之三—–TreeMap"></a>Map的实现类之三—–TreeMap</h2><ul>
<li>向TreeMap中添加key-value，要求key必须是由同一个类创建的对象</li>
<li>按照key进行排序：自然排序和定制排序</li>
</ul>
<p><strong>User中重写的compareTo()方法：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按照name从小到大排，如果name相同，按照id从小到大排</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(User o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> compare = <span class="keyword">this</span>.name.compareTo(o.name);</span><br><span class="line">    <span class="keyword">if</span> (compare == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.compare(<span class="keyword">this</span>.id,o.id);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> compare;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>自然排序：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    TreeMap treeMap = <span class="keyword">new</span> TreeMap();</span><br><span class="line">    User user1 = <span class="keyword">new</span> User(<span class="number">1001</span>,<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">    User user2 = <span class="keyword">new</span> User(<span class="number">1004</span>,<span class="string">&quot;Rose&quot;</span>);</span><br><span class="line">    User user3 = <span class="keyword">new</span> User(<span class="number">1002</span>,<span class="string">&quot;Mary&quot;</span>);</span><br><span class="line">    User user4 = <span class="keyword">new</span> User(<span class="number">1003</span>,<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">    User user5 = <span class="keyword">new</span> User(<span class="number">1005</span>,<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">    treeMap.put(user1,<span class="number">112</span>);</span><br><span class="line">    treeMap.put(user2,<span class="number">154</span>);</span><br><span class="line">    treeMap.put(user3,<span class="number">257</span>);</span><br><span class="line">    treeMap.put(user4,<span class="number">398</span>);</span><br><span class="line">    treeMap.put(user5,<span class="number">398</span>);</span><br><span class="line"></span><br><span class="line">    Set entrySet = treeMap.entrySet();</span><br><span class="line">    Iterator iterator = entrySet.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        Object o = iterator.next();</span><br><span class="line">        Map.Entry entry = (Map.Entry) o;</span><br><span class="line">        System.out.println(entry.getKey() + <span class="string">&quot;--&gt;&quot;</span> + entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">User&#123;id&#x3D;1001, name&#x3D;&#39;Jack&#39;&#125;--&gt;112</span><br><span class="line">User&#123;id&#x3D;1002, name&#x3D;&#39;Mary&#39;&#125;--&gt;257</span><br><span class="line">User&#123;id&#x3D;1004, name&#x3D;&#39;Rose&#39;&#125;--&gt;154</span><br><span class="line">User&#123;id&#x3D;1003, name&#x3D;&#39;Tom&#39;&#125;--&gt;398</span><br><span class="line">User&#123;id&#x3D;1005, name&#x3D;&#39;Tom&#39;&#125;--&gt;398</span><br></pre></td></tr></table></figure>
<p><strong>定制排序：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Comparator&lt;User&gt; comparator = <span class="keyword">new</span> Comparator&lt;User&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="comment">//先按name从小到大排，如果name一样，则按id从大到小排</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(User o1, User o2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> compare = o1.getName().compareTo(o2.getName());</span><br><span class="line">            <span class="keyword">if</span> (compare != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> compare;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> -Integer.compare(o1.getId(), o2.getId());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    TreeMap treeMap = <span class="keyword">new</span> TreeMap(comparator);</span><br><span class="line">    User user1 = <span class="keyword">new</span> User(<span class="number">1001</span>,<span class="string">&quot;Jack&quot;</span>);</span><br><span class="line">    User user2 = <span class="keyword">new</span> User(<span class="number">1004</span>,<span class="string">&quot;Rose&quot;</span>);</span><br><span class="line">    User user3 = <span class="keyword">new</span> User(<span class="number">1002</span>,<span class="string">&quot;Mary&quot;</span>);</span><br><span class="line">    User user4 = <span class="keyword">new</span> User(<span class="number">1003</span>,<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">    User user5 = <span class="keyword">new</span> User(<span class="number">1005</span>,<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">    treeMap.put(user1,<span class="number">112</span>);</span><br><span class="line">    treeMap.put(user2,<span class="number">154</span>);</span><br><span class="line">    treeMap.put(user3,<span class="number">257</span>);</span><br><span class="line">    treeMap.put(user4,<span class="number">398</span>);</span><br><span class="line">    treeMap.put(user5,<span class="number">398</span>);</span><br><span class="line"></span><br><span class="line">    Set entrySet = treeMap.entrySet();</span><br><span class="line">    Iterator iterator = entrySet.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        Object o = iterator.next();</span><br><span class="line">        Map.Entry entry = (Map.Entry) o;</span><br><span class="line">        System.out.println(entry.getKey() + <span class="string">&quot;--&gt;&quot;</span> + entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">User&#123;id&#x3D;1001, name&#x3D;&#39;Jack&#39;&#125;--&gt;112</span><br><span class="line">User&#123;id&#x3D;1002, name&#x3D;&#39;Mary&#39;&#125;--&gt;257</span><br><span class="line">User&#123;id&#x3D;1004, name&#x3D;&#39;Rose&#39;&#125;--&gt;154</span><br><span class="line">User&#123;id&#x3D;1005, name&#x3D;&#39;Tom&#39;&#125;--&gt;398</span><br><span class="line">User&#123;id&#x3D;1003, name&#x3D;&#39;Tom&#39;&#125;--&gt;398</span><br></pre></td></tr></table></figure>
<h2 id="Map的古老实现类之四—–Hashtable"><a href="#Map的古老实现类之四—–Hashtable" class="headerlink" title="Map的古老实现类之四—–Hashtable"></a>Map的古老实现类之四—–Hashtable</h2><h2 id="⭐HashMap和Hashtable的不同之处"><a href="#⭐HashMap和Hashtable的不同之处" class="headerlink" title="⭐HashMap和Hashtable的不同之处"></a>⭐HashMap和Hashtable的不同之处</h2><p><strong>参考</strong>：<a href="https://zhuanlan.zhihu.com/p/37607299">知乎链接</a></p>
<ul>
<li><p><strong>线程安全性和效率不同：</strong></p>
<ul>
<li>HashMap是线程不安全的，效率高；</li>
<li>Hashtable是线程安全的，效率低；</li>
</ul>
</li>
<li><p><strong>容纳数据：</strong></p>
<ul>
<li>HashMap可以存储null的key和value；</li>
<li>Hashtable不能；</li>
</ul>
</li>
<li><p><strong>出现时间：</strong></p>
<ul>
<li>Hashtable是早期提供的接口；</li>
<li>HashMap是新版JDK提供的接口；</li>
</ul>
</li>
<li><p><strong>继承不同：</strong></p>
<ul>
<li>public class Hashtable extends Dictionary implements Map</li>
<li>public class HashMap extends AbstractMap implements Map</li>
</ul>
</li>
<li><p><strong>底层数组的长度：</strong></p>
<ul>
<li>HashMap的底层数组的长度必须为2^n，这样做的好处是为以后的hash算法做准备；</li>
<li>Hashtable底层数组的长度可以为任意值，这就造成了当底层数组长度为合数的时候，Hashtable的hash算法散射不均匀，容易产生hash冲突；</li>
</ul>
</li>
<li><p><strong>计算存储位置：</strong></p>
<ul>
<li>HashMap的hash算法使用&amp;运算，运算速度快；</li>
<li>Hashtable的hash算法使用%运算，运算速度慢；</li>
</ul>
</li>
<li><p><strong>扩容：</strong></p>
<ul>
<li>HashMap数组的扩容的整体思想就是创建一个长度为原先2倍的数组。然后对原数组进行遍历和复制；</li>
<li>Hashtable的扩容将先创建一个长度为原长度2倍的数组，再使用头插法将链表进行反序；</li>
</ul>
</li>
<li><p><strong>结构：</strong></p>
<ul>
<li>HashMap底层使用数组+链表+红黑树；</li>
<li>Hashtable底层使用数组+链接；</li>
</ul>
</li>
</ul>
<h2 id="Map的实现类之五—–Properties"><a href="#Map的实现类之五—–Properties" class="headerlink" title="Map的实现类之五—–Properties"></a>Map的实现类之五—–Properties</h2><ul>
<li>Properties类是Hashtable的子类，该对象用于处理属性文件；</li>
<li>key和value都是String类型；</li>
</ul>
<h1 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h1><p>Collections提供了一些列静态的方法对集合元素进行排序，查找和修改等操作，还提供了对集合对象设置不可变、对集合对象实现同步控制等方法。</p>
<h2 id="Collection和Collections的区别？"><a href="#Collection和Collections的区别？" class="headerlink" title="Collection和Collections的区别？"></a>Collection和Collections的区别？</h2><ul>
<li>Collection是一个接口，存储单列数据，有List，Set子接口</li>
<li>Collections是一个工具类，用来操作Collection、Map的工具类</li>
</ul>
<h2 id="Collections工具类常用方法"><a href="#Collections工具类常用方法" class="headerlink" title="Collections工具类常用方法"></a>Collections工具类常用方法</h2><ul>
<li><strong>排序操作</strong><ul>
<li><strong>reverse(List&lt;?&gt; list)：</strong>反转指定列表中元素的顺序。</li>
<li><strong>shuffle(List&lt;?&gt; list)：</strong>使用默认的随机源随机排列指定的列表。</li>
<li><strong>sort(List<T> list)：</T></strong>根据元素的自然顺序对指定的List集合元素按升序排序。</li>
<li>**sort(List<T> list, Comparator&lt;? super T&gt; c)**：根据指定的比较器引起的顺序对指定的列表进行排序。</T></li>
<li><strong>swap(List&lt;?&gt; list, int i, int j)：</strong>交换指定列表中指定位置的元素。</li>
</ul>
</li>
<li><strong>查找、替换</strong><ul>
<li>**max(Collection&lt;? extends T&gt; coll)**：根据其元素的 自然顺序返回给定集合的最大元素。</li>
<li><strong>max(Collection&lt;? extends T&gt; coll, Comparator&lt;? super T&gt; comp)：</strong>根据指定的比较器引发的顺序返回给定集合的最大元素。</li>
<li>**min(Collection&lt;? extends T&gt; coll)**：根据其元素的 自然顺序返回给定集合的最小元素。</li>
<li><strong>min(Collection&lt;? extends T&gt; coll, Comparator&lt;? super T&gt; comp)：</strong>根据指定的比较器引发的顺序返回给定集合的最小元素。</li>
<li><strong>frequency(Collection&lt;?&gt; c, Object o)：</strong>返回指定集合中与指定对象相等的元素数。</li>
<li><strong>copy(List&lt;? super T&gt; dest, List&lt;? extends T&gt; src)：</strong>将所有元素从一个列表复制到另一个列表中。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//错误写法，报异常：java.lang.IndexOutOfBoundsException: Source does not fit in dest</span></span><br><span class="line"><span class="comment">//因为srcSize &gt; dest.size()</span></span><br><span class="line">ArrayList list1 = <span class="keyword">new</span> ArrayList();</span><br><span class="line">Collections.copy(list1,list);</span><br><span class="line">System.out.println(list1);</span><br><span class="line"><span class="comment">//正确的方式</span></span><br><span class="line">List list1 = Arrays.asList(<span class="keyword">new</span> Object[list.size()]);</span><br><span class="line">Collections.copy(list1,list);</span><br><span class="line">System.out.println(list1);</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>同步控制</strong></li>
</ul>
<p>这些方法可以使将指定集合包装成线程同步的集合，从而解决多线程并发访问集合时的线程安全问题。</p>
<p><img src="/p/1.jpg" alt="同步控制方法集锦"></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>集合</category>
      </categories>
      <tags>
        <tag>集合</tag>
        <tag>Collection</tag>
        <tag>ArrayList</tag>
        <tag>HashMap</tag>
      </tags>
  </entry>
</search>
